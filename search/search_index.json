{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Lexy","text":"<p>Lexy is a data platform for building AI-powered applications. You can use Lexy to:</p> <ul> <li>Build Retrieval Augmented Generation (RAG) applications.</li> <li>Provide relevant context for AI agents.</li> <li>Add long-term memory to chat-based applications.</li> <li>Extract structured data from unstructured documents.</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>REST API for storing, embedding, and retrieving documents.</li> <li>Pipeline-based document processing using your own Python functions.</li> <li>Change data capture for real-time updates.</li> <li>Secure file storage using Amazon S3 or Google Cloud Storage.</li> <li>Open source Apache 2.0 license.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Follow the steps in the installation guide to install Lexy.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>See the quickstart guide to get started with Lexy.</p>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Review the following tutorials for a step-by-step guide on how to use Lexy.</p> <ul> <li>Getting started for an overview of Lexy's core concepts.</li> <li>Retrieval Augmented Generation (RAG) for how to implement RAG using Lexy.</li> <li>Multimodal image search for how to use Lexy to build a multimodal search engine.</li> <li>Custom transformers for using your own functions as transformers.</li> <li>Document filters shows how to build pipelines for different types of documents.</li> <li>Structured data extraction for how to extract structured data from documents.</li> </ul>"},{"location":"#reference","title":"Reference","text":"<p>See the API reference for detailed documentation on Lexy's API.</p> <p>The Python SDK is a Python client for Lexy, with detailed documentation.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Check out the developer notes for guidance on contributing to the Lexy codebase.</p>"},{"location":"#faqs","title":"FAQs","text":"<p>Any questions? Check out the FAQ for answers to common questions.</p> <p>If you can't find the answer you're looking for, please contact us.</p>"},{"location":"contributing/","title":"Contributing to Lexy","text":"<p>This document provides guidance for developers who want to contribute to the Lexy codebase.</p> <p>To set up a development environment, simply follow the instructions in the installation guide. The command <code>make install-dev</code> will install the dev, docs, and test dependencies.</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Take a look at open issues on GitHub if you'd like to contribute to the project. This is also a great place to submit questions, feature requests, and bug reports.</p>"},{"location":"contributing/#developer-notes","title":"Developer Notes","text":""},{"location":"contributing/#makefile","title":"Makefile","text":"<p>Many of the common commands for development are available in the <code>Makefile</code>.</p>"},{"location":"contributing/#running-tests","title":"Running tests","text":"<p>When you open a pull request, tests will run automatically on GitHub Actions. To run tests locally, you can use the following make command.</p> <pre><code>make run-tests\n</code></pre> <p>This command will run tests for the Lexy server and Lexy Python SDK. If you want to run the tests separately, you can use the following commands.</p> <pre><code># Run tests for Lexy server\npytest lexy_tests\n\n# Run tests for Python SDK\npytest sdk-python\n</code></pre> <p>To run tests inside an already running lexy-server container, use the following command.</p> <pre><code>make run-tests-docker\n</code></pre> <p>To create a new lexy-server container and run tests, use the following command. This requires the rest of the stack to be running.</p> <pre><code>make test-lexy-server\n</code></pre> <p>Note that this option will still mount the current directory, and is not ideal for isolated testing.</p>"},{"location":"contributing/#adding-a-new-migration","title":"Adding a new migration","text":"<p>To add a new <code>alembic</code> migration, first create the migration file.</p> <pre><code># Create a new migration\nalembic revision --autogenerate -m \"Short description of the migration\"\n</code></pre> <p>Check the migration file in the <code>alembic/versions</code> directory and make any necessary changes.</p> <pre><code># Apply the migration\nalembic upgrade head\n\n# Check the migration status\nalembic current\n</code></pre> <p>Add the migration file to version control and open a pull request.</p>"},{"location":"contributing/#updating-docker-containers","title":"Updating Docker containers","text":"<p>When you pull changes from the repository, you may need to update your local Docker containers. To rebuild the server and worker containers, and apply database migrations, you can run the following make command:</p> <pre><code>make update-dev-containers\n</code></pre> <p>To rebuild the server and worker containers only (without migrations), run the following.</p> <pre><code>docker compose up --build -d --no-deps lexyserver lexyworker\n</code></pre> <p>If for some reason you need to install the new dependencies without rebuilding your containers, run the following:</p> <pre><code>docker exec lexy-server poetry install --no-root -E \"lexy_transformers\"\ndocker exec lexy-celeryworker poetry install --no-root -E \"lexy_transformers\"\n</code></pre>"},{"location":"contributing/#release-docker-containers","title":"Release Docker containers","text":"<p>Docker containers are built for each release and hosted on GitHub Container Registry. Packages are available here.</p>"},{"location":"contributing/#pip-installing-into-docker-containers","title":"Pip installing into Docker containers","text":"<p>Sometimes you may need to install a new package into the Docker container, since it's much faster than updating <code>pyproject.toml</code> and rebuilding. You can do this by running the following:</p> <pre><code>docker exec lexy-server pip install &lt;your_package&gt;\ndocker exec lexy-celeryworker pip install &lt;your_package&gt;\n</code></pre> <p>If you end up keeping the package, make sure to update <code>pyproject.toml</code> and recreate the <code>poetry.lock</code> file if needed.</p> <pre><code>poetry add &lt;your_package&gt;\npoetry check\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#how-do-i-add-a-new-environment-variable","title":"How do I add a new environment variable?","text":"<p>To add a new environment variable, add it to your <code>.env</code> file. If you don't have a <code>.env</code> file, you can simply create it by copying the file <code>.env.example</code>.</p> <pre><code>cp -n .env.example .env\n</code></pre> <p>Then open the <code>.env</code> file and add your new environment variable.</p> .env<pre><code># Lexy settings\nSECRET_KEY=super_secret_key\nDEFAULT_STORAGE_SERVICE=s3\nDEFAULT_STORAGE_BUCKET=your_s3_bucket_name\n\n# Other secrets\nOPENAI_API_KEY=your_secret_api_key\nNEW_ENV_VAR=your_new_env_var_value\n</code></pre> <p>Warning</p> <p>Updating the <code>.env</code> file will not automatically update the environment variables in your docker containers. You need to rebuild the containers for the new environment variable to take effect. See below.</p> <p>You should add environment variables before building your docker containers. Or if you have already built your containers, you can run the following to rebuild the server and worker containers.</p> <pre><code>make rebuild-dev-containers\n</code></pre> <p>Verify that your new environment variable has been added to the server and worker containers.</p> <pre><code>docker exec lexy-server env | grep -i NEW_ENV_VAR\ndocker exec lexy-celeryworker env | grep -i NEW_ENV_VAR\n</code></pre> A note about environment variables <p>You can also access the environment variables in your <code>.env</code> file using the <code>lexy.core.config</code> module. In that case, you don't need to rebuild your containers.</p> <p>Ideally, the variables that are loaded through <code>lexy.core.config</code> should be those related to the application's configuration, whereas user-specific environment variables should be loaded through Python's <code>os.environ</code> module.</p>"},{"location":"faq/#why-is-lexy-written-in-python-isnt-python-slow","title":"Why is Lexy written in Python? Isn't Python slow?","text":"<p>Python is (1) easy to read and write, (2) extremely popular in the data and machine learning communities, and (3) great for orchestration of complex systems. It's not yet clear to us what the biggest bottlenecks will be, but we are confident that we can optimize performance using C/C++ bindings. And if that doesn't work, we'll just RIIR.</p>"},{"location":"faq/#i-think-the-name-lexy-is-super-cool","title":"I think the name Lexy is super cool.","text":"<p>Technically this isn't a question, but we agree with you! The name comes from \"lexicon,\" defined as the vocabulary of a person, language, or branch of knowledge.</p>"},{"location":"installation/","title":"Installation","text":"<p>To run Lexy locally, you'll need Docker installed. You'll also need Python 3.11 or greater. To install Lexy, you can either build from source (recommended) or install from PyPI (standalone mode).</p>"},{"location":"installation/#build-from-source","title":"Build from source","text":""},{"location":"installation/#clone-the-repo","title":"Clone the repo","text":"<pre><code>git clone https://github.com/lexy-ai/lexy.git\n</code></pre>"},{"location":"installation/#install-dependencies","title":"Install dependencies","text":"<p>First create a virtual environment. Make sure that you're using Python 3.11 or greater. You can check your Python version by running <code>python3 --version</code>.</p> <pre><code># Change to the lexy directory\ncd lexy\n# Create a virtualenv\npython3 -m venv venv\nsource venv/bin/activate\n</code></pre> <p>Next, install the dev dependencies. This will also create a <code>.env</code> file in the working directory if it doesn't exist already.</p> <pre><code># Install dev dependencies\nmake install-dev\n</code></pre>"},{"location":"installation/#run-docker-compose","title":"Run docker compose","text":"<p>To build and run the docker containers, run the following command:</p> <pre><code># Build and run docker containers\ndocker compose up --build -d\n</code></pre> <p>To stop the containers, run <code>docker compose down</code>.</p>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>Use this method if you're already familiar with Lexy and are using it as a dependency in your own project. You'll need to provide instances of the Lexy server, worker, and database. See the Quickstart guide for more information and a detailed example.</p> <pre><code># Install server\npip install lexy[all]\n\n# Install Python client\npip install lexy-py\n\n# Initialize Lexy\nlexy init\n\n# Optional: Create a docker-compose file\nlexy docker\n</code></pre>"},{"location":"installation/#configuring-storage","title":"Configuring storage","text":"<p>In order to upload and store files to Lexy, you'll need to configure either Amazon S3 or Google Cloud Storage.</p>"},{"location":"installation/#amazon-s3","title":"Amazon S3","text":"<p>To configure Amazon S3, you can use <code>aws configure</code> on the command line (recommended) or set the value of <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> in your <code>.env</code> file.</p> <p>If you choose to use <code>aws configure</code>, make sure to uncomment the following line in <code>docker-compose.yaml</code> in order for your credentials to be available inside of the <code>lexyserver</code> container.</p> <pre><code>    volumes:\n      # Uncomment the following line to mount local AWS credentials\n      - $HOME/.aws/credentials:/root/.aws/credentials:ro\n</code></pre> <p>You'll also need to specify an S3 bucket for file storage (for which your AWS credentials should have full access). You can do so by adding <code>DEFAULT_STORAGE_BUCKET=&lt;name-of-your-S3-bucket&gt;</code> to your <code>.env</code> file.</p> <p>Remember to rebuild your dev containers for the change to take effect (run <code>make rebuild-dev-containers</code> on the command line).</p>"},{"location":"installation/#google-cloud-storage","title":"Google Cloud Storage","text":"<p>To use Google Cloud Storage, you'll need to set <code>DEFAULT_STORAGE_SERVICE=gcs</code> in your <code>.env</code> file. You'll also need to create a service account, and set the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable to the path of your service account credentials. You can do so by adding the following to your <code>.env</code> file:</p> <pre><code>GOOGLE_APPLICATION_CREDENTIALS=&lt;path-to-your-service-account-credentials&gt;\n</code></pre> <p>You'll also need to specify a GCS bucket for file storage (for which your service account should have full access). You can do so by adding <code>DEFAULT_STORAGE_BUCKET=&lt;name-of-your-GCS-bucket&gt;</code> to your <code>.env</code> file.</p> <p>Remember to rebuild your dev containers for the change to take effect (run <code>make rebuild-dev-containers</code> on the command line).</p> Example .env settings Amazon S3Google Cloud Storage <pre><code>DEFAULT_STORAGE_SERVICE=s3\nDEFAULT_STORAGE_BUCKET=your_s3_bucket_name\nAWS_ACCESS_KEY_ID=your_aws_access_key_id\nAWS_SECRET_ACCESS_KEY=your_aws_secret_access_key\n</code></pre> <pre><code>DEFAULT_STORAGE_SERVICE=gcs\nDEFAULT_STORAGE_BUCKET=your_gcs_bucket_name\nGOOGLE_APPLICATION_CREDENTIALS=/path/to/your/service-account-credentials.json\n</code></pre>"},{"location":"installation/#using-openai-transformers","title":"Using OpenAI transformers","text":"<p>To use OpenAI embeddings in Lexy, you'll need to set the <code>OPENAI_API_KEY</code> environment variable. You can do so by adding the following to your <code>.env</code> file:</p> <pre><code>OPENAI_API_KEY=&lt;your-openai-api-key&gt;\n</code></pre> <p>Do this before building your docker containers. Or, if you've already run <code>docker compose up</code>, you can run the following to rebuild the server and worker containers.</p> <pre><code># Rebuild the server and worker containers\nmake rebuild-dev-containers\n</code></pre>"},{"location":"installation/#lexy-dashboard-wip","title":"Lexy dashboard (WIP)","text":"<p>Lexy comes with a built-in dashboard to visualize pipelines. This is still under development, but you can run it locally.</p> <p></p> <p>To start the dashboard, make sure you have Node.js installed. Then, from the root directory, run the following commands:</p> <pre><code>cd dashboard\nnpm install\nnpm run dev\n</code></pre> <p>The dashboard will be running at http://localhost:3000.</p>"},{"location":"installation/#where-to-find-services","title":"Where to find services","text":"<p>The server will be running at http://localhost:9900. In addition, you can find the following services.</p> Service URL Notes Lexy API http://localhost:9900/docs Swagger API docs Flower http://localhost:5556 Celery task monitor RabbitMQ http://localhost:15672 Username: <code>guest</code>, Password: <code>guest</code> Postgres http://localhost:5432 Database: <code>lexy</code>, Username: <code>postgres</code>, Password: <code>postgres</code> Project docs http://localhost:8000 Run <code>make serve-docs</code>Username: <code>lexy</code>, Password: <code>guest</code> Lexy dashboard http://localhost:3000 Dashboard to show pipelines (WIP)"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#pycharm-issues","title":"PyCharm issues","text":"<p>If your virtualenv keeps getting bjorked by PyCharm, make sure that you're following the instructions above verbatim, and using <code>venv</code> instead of <code>.venv</code> for the path of your virtual environment.</p>"},{"location":"installation/#other-issues","title":"Other issues","text":"<p>If you encounter any issues while installing or using Lexy, please open an issue on GitHub.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Lexy is a data framework for building AI-powered applications. It provides a simple API to store and retrieve documents, and to apply transformations to those documents.</p> <p>Follow the instructions in the installation guide to install Lexy.</p>"},{"location":"quickstart/#concepts","title":"Concepts","text":"<p>Lexy has the following core concepts:</p> <ul> <li>Collections: A collection is a group of documents.</li> <li>Documents: A document consists of content (text, image, file, etc.) and metadata.</li> <li>Transformers: A transformer is a function that takes a document as input and returns a transformed version of that document.</li> <li>Indexes: An index is used to store and retrieve the output of transformed documents, including embeddings.</li> <li>Bindings: A binding is a connection between a collection, a transformer, and an index. When a document is added to a collection,   the transformer is applied to the document, and the result is stored in the index.</li> </ul> <p>For an overview of Lexy's core concepts, see the Getting started tutorial.</p>"},{"location":"quickstart/#building-with-lexy","title":"Building with Lexy","text":""},{"location":"quickstart/#project-structure","title":"Project structure","text":"<p>Here's a sample directory structure for a project using Lexy:</p> <pre><code>my-project\n\u251c\u2500\u2500 mypkg\n\u2502   \u2514\u2500\u2500 src\n\u251c\u2500\u2500 pipelines  # Lexy pipelines (1)\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 code.py\n\u2502   \u251c\u2500\u2500 my_custom_transformer.py\n\u2502   \u251c\u2500\u2500 my_first_pipeline.py\n\u2502   \u251c\u2500\u2500 pdf_embeddings.py\n\u2502   \u2514\u2500\u2500 requirements.txt  # (2)!\n\u251c\u2500\u2500 .env\n\u2514\u2500\u2500 docker-compose.yaml  # (3)!\n</code></pre> <ol> <li>This is the Lexy pipelines directory, defined by the environment variable     <code>PIPELINE_DIR</code>. The modules in this directory are imported and run by the     <code>lexyworker</code> container.</li> <li>Extra requirements for your pipelines or custom transformers. These packages will     be installed whenever you restart the <code>lexyworker</code> container.</li> <li>You can generate this file using the Lexy CLI. Run <code>lexy docker</code> on the command     line to create a sample compose file.</li> </ol>"},{"location":"quickstart/#pipelines","title":"Pipelines","text":"<p>Lexy uses a <code>pipelines</code> directory to load your pipelines and custom transformers. This directory defaults to <code>./pipelines</code> but can be set using the <code>PIPELINE_DIR</code> environment variable in your <code>.env</code> file.</p> <p>You can install custom packages required for your pipelines or transformers in <code>requirements.txt</code>. These packages will be installed in the <code>lexyworker</code> container.</p> Example <code>pipelines</code> directory code.pypdf_embeddings.pyrequirements.txt <pre><code>import tree_sitter_languages\n\nfrom lexy.models import Document\nfrom lexy.transformers import lexy_transformer\n\n\ndef parse_code(content):\n    # just an example - replace with your own logic\n    return [\n        {'text': 'my comment', 'line_no': 1, 'filename': 'example.py'}\n    ]\n\n\n@lexy_transformer(name='code.extract_comments.v1')\ndef get_comments(doc: Document) -&gt; list[dict]:\n    comments = []\n    for c in parse_code(doc.content):\n        comments.append({\n            'comment_text': c['text'],\n            'comment_meta': {\n                'line_no': c['line_no'],\n                'filename': c['filename']\n            }\n        })\n    return comments\n</code></pre> <pre><code>from io import BytesIO\n\nimport httpx\nimport pypdf\n\nfrom lexy.models import Document\nfrom lexy.transformers import lexy_transformer\nfrom lexy.transformers.embeddings import text_embeddings\n\n\ndef pdf_reader_from_url(url: str) -&gt; pypdf.PdfReader:\n    response = httpx.get(url)\n    return pypdf.PdfReader(BytesIO(response.content))\n\n\n@lexy_transformer(name='pdf.embed_pages.text_only')\ndef embed_pdf_pages(doc: Document) -&gt; list[dict]:\n\n    pdf = pdf_reader_from_url(doc.object_url)\n    pages = []\n\n    for page_num, page in enumerate(pdf.pages):\n        page_text = page.extract_text()\n        images = [im.name for im in page.images]\n        p = {\n            'page_text': page_text,\n            'page_text_embedding': text_embeddings(page_text),\n            'page_meta': {\n                'page_num': page_num,\n                'page_text_length': len(page_text),\n                'images': images,\n                'n_images': len(images)\n            }\n        }\n        pages.append(p)\n\n    return pages\n</code></pre> <pre><code># Extra package requirements for pipelines\npypdf\ntree-sitter==0.20.4\ntree-sitter-languages==1.8.0\n</code></pre>"},{"location":"quickstart/#configuration","title":"Configuration","text":"<p>You can build and run Lexy using Docker Compose.</p> <p>Here is an example of <code>docker-compose.yaml</code> and a <code>.env</code> file for a project using Lexy with Google Cloud Storage as the default storage service.</p> <p>The example below uses the <code>latest</code> tag, which you can replace with a specific version if needed (e.g., <code>v0.0.2</code>). Images are built for each release and hosted on GitHub Container Registry. Available packages are here.</p> <p>Tip</p> <p>You can generate the <code>docker-compose.yaml</code> file below using the Lexy CLI. Run <code>lexy docker</code> on the command line to create the file.</p> Example configuration using Google Cloud Storage docker-compose.yaml.env <pre><code>name: my-project\n\nservices:\n  lexyserver:\n    image: ghcr.io/lexy-ai/lexy/lx-server:latest\n    hostname: lexy_server\n    depends_on:\n      - db_postgres\n    ports:\n      - \"9900:9900\"\n    env_file:\n      - .env\n    environment:\n      - OPENAI_API_KEY=${OPENAI_API_KEY}\n      - PIPELINE_DIR=/home/app/pipelines\n      - GOOGLE_APPLICATION_CREDENTIALS=/run/secrets/gcp_credentials\n    volumes:\n      - ${PIPELINE_DIR:-./pipelines}:/home/app/pipelines\n    secrets:\n      - gcp_credentials\n\n  lexyworker:\n    image: ghcr.io/lexy-ai/lexy/lx-worker:latest\n    hostname: celeryworker\n    depends_on:\n      - lexyserver\n      - queue\n    restart: always\n    env_file:\n      - .env\n    environment:\n      - PIPELINE_DIR=/home/app/pipelines\n    volumes:\n      - ${PIPELINE_DIR:-./pipelines}:/home/app/pipelines\n\n  db_postgres:\n    image: ghcr.io/lexy-ai/lexy/lx-postgres:latest\n    restart: always\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - db-postgres:/var/lib/postgresql/data\n\n  queue:\n    image: rabbitmq:3.9.10-management\n    restart: always\n    ports:\n      - \"5672:5672\"\n      - \"15672:15672\"\n\n  flower:\n    image: mher/flower\n    restart: always\n    ports:\n      - \"5556:5555\"\n    command: celery --broker=amqp://guest:guest@queue:5672// flower -A lexy.main.celery --broker_api=http://guest:guest@queue:15672/api/vhost\n    depends_on:\n      - lexyserver\n      - lexyworker\n      - queue\n    environment:\n      - CELERY_BROKER_URL=amqp://guest:guest@queue:5672//\n      - CELERY_RESULT_BACKEND=db+postgresql://postgres:postgres@db_postgres/lexy\n      - CELERY_BROKER_API_URL=http://guest:guest@queue:15672/api/vhost\n      - C_FORCE_ROOT=true\n      - FLOWER_UNAUTHENTICATED_API=true\n\nvolumes:\n  db-postgres:\n    driver: local\n\nsecrets:\n  gcp_credentials:\n    file: ${GOOGLE_APPLICATION_CREDENTIALS:-/dev/null}\n\nnetworks:\n  default:\n    name: lexy-net\n    external: false\n</code></pre> <pre><code># Google Cloud Storage\nDEFAULT_STORAGE_SERVICE=gcs\nDEFAULT_STORAGE_BUCKET=your_gcs_bucket_name\nGOOGLE_APPLICATION_CREDENTIALS=/path/to/your/service-account-credentials.json\n\n# OpenAI API key\nOPENAI_API_KEY=your-openai-api-key\n</code></pre>"},{"location":"quickstart/#testing","title":"Testing","text":"<p>You can run tests inside the <code>lexyserver</code> container to ensure that Lexy is working as expected.</p> <p>In the example project above, you first bring up your project's stack using Docker Compose:</p> <pre><code>docker compose up -d\n</code></pre> <p>Then use the following commands to run tests inside the running <code>lexyserver</code> container:</p> <pre><code>docker compose exec -it lexyserver pytest lexy_tests\ndocker compose exec -it lexyserver pytest sdk-python\n</code></pre> <p>Or to run tests in a single command:</p> <pre><code>docker compose exec -it lexyserver sh -c \"pytest lexy_tests &amp;&amp; pytest sdk-python\"\n</code></pre> <p>If instead you want to run tests inside a new <code>lexyserver</code> container, use the following command:</p> <pre><code>docker compose run -it --rm --no-deps lexyserver sh -c \"pytest lexy_tests &amp;&amp; pytest sdk-python\"\n</code></pre>"},{"location":"quickstart/#lexy-api","title":"Lexy API","text":"<p>The Lexy server is a RESTful API that provides endpoints for storing and retrieving documents, applying transformations, and managing collections and indexes.</p> <p>The API is documented using Swagger. You can view the Swagger UI in the REST API docs or access it locally at <code>http://localhost:9900/docs</code> when running the Lexy server.</p> <p></p>"},{"location":"quickstart/#python-sdk","title":"Python SDK","text":"<p><code>lexy-py</code> is the Python SDK used to interact with the Lexy server.</p> <p>The SDK provides a <code>LexyClient</code> class that you can use to interact with the Lexy server. Here's an example of how to list collections using the Python SDK:</p> <pre><code>from lexy_py import LexyClient\n\nlx = LexyClient()\nlx.list_collections()\n</code></pre> <p>For more information on how to use the Python SDK, see the Python SDK reference.</p>"},{"location":"reference/lexy_py/binding/","title":"Documentation for <code>Binding</code>","text":""},{"location":"reference/lexy_py/binding/#lexy_py.binding.models.Binding","title":"<code>lexy_py.binding.models.Binding</code>","text":"<p>             Bases: <code>BindingModel</code></p> <p>Binding model</p> Source code in <code>sdk-python/lexy_py/binding/models.py</code> <pre><code>class Binding(BindingModel):\n    __doc__ = BindingModel.__doc__\n    _client: Optional[\"LexyClient\"] = PrivateAttr(default=None)\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        self._client = data.pop(\"client\", None)\n        self.collection: Collection = Collection(\n            **self.collection.model_dump(), client=self._client\n        )\n        self.index: Index = Index(**self.index.model_dump(), client=self._client)\n        self.transformer: Transformer = Transformer(\n            **self.transformer.model_dump(), client=self._client\n        )\n\n    @property\n    def client(self) -&gt; \"LexyClient\":\n        if not self._client:\n            raise ValueError(\"API client has not been set.\")\n        return self._client\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.models.BindingModel","title":"<code>lexy_py.binding.models.BindingModel</code>","text":"<p>             Bases: <code>BindingBase</code></p> <p>Binding model</p> <p>Parameters:</p> Name Type Description Default <code>binding_id</code> <code>int</code> required <code>collection_id</code> <code>str</code> required <code>transformer_id</code> <code>str</code> required <code>index_id</code> <code>str</code> required <code>collection</code> <code>CollectionModel</code> required <code>transformer</code> <code>TransformerModel</code> required <code>index</code> <code>IndexModel</code> required <code>created_at</code> <code>datetime</code> required <code>updated_at</code> <code>datetime</code> required Source code in <code>sdk-python/lexy_py/binding/models.py</code> <pre><code>class BindingModel(BindingBase):\n    \"\"\"Binding model\"\"\"\n\n    binding_id: int\n    collection_id: str\n    transformer_id: str\n    index_id: str\n    collection: CollectionModel\n    transformer: TransformerModel\n    index: IndexModel\n    created_at: datetime\n    updated_at: datetime\n\n    def __repr__(self):\n        return (\n            f\"&lt;Binding(\"\n            f\"id={self.binding_id}, \"\n            f\"status={self.status.name}, \"\n            f\"collection='{self.collection_id}', \"\n            f\"transformer='{self.transformer_id}', \"\n            f\"index='{self.index_id}')&gt;\"\n        )\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient","title":"<code>lexy_py.binding.client.BindingClient</code>","text":"<p>This class is used to interact with the Lexy Bindings API.</p> <p>Attributes:</p> Name Type Description <code>aclient</code> <code>AsyncClient</code> <p>Asynchronous API client.</p> <code>client</code> <code>Client</code> <p>Synchronous API client.</p> Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>class BindingClient:\n    \"\"\"\n    This class is used to interact with the Lexy Bindings API.\n\n    Attributes:\n        aclient (httpx.AsyncClient): Asynchronous API client.\n        client (httpx.Client): Synchronous API client.\n    \"\"\"\n\n    def __init__(self, lexy_client: \"LexyClient\") -&gt; None:\n        self._lexy_client = lexy_client\n\n    @property\n    def aclient(self) -&gt; httpx.AsyncClient:\n        return self._lexy_client.aclient\n\n    @property\n    def client(self) -&gt; httpx.Client:\n        return self._lexy_client.client\n\n    def list_bindings(self) -&gt; list[Binding]:\n        \"\"\"Synchronously get a list of all bindings.\n\n        Returns:\n            list[Binding]: A list of all bindings.\n        \"\"\"\n        r = self.client.get(\"/bindings\")\n        handle_response(r)\n        return [Binding(**binding, client=self._lexy_client) for binding in r.json()]\n\n    async def alist_bindings(self) -&gt; list[Binding]:\n        \"\"\"Asynchronously get a list of all bindings.\n\n        Returns:\n            list[Binding]: A list of all bindings.\n        \"\"\"\n        r = await self.aclient.get(\"/bindings\")\n        handle_response(r)\n        return [Binding(**binding, client=self._lexy_client) for binding in r.json()]\n\n    def create_binding(\n        self,\n        *,\n        collection_name: str = None,\n        collection_id: str = None,\n        transformer_id: str = None,\n        index_id: str = None,\n        description: Optional[str] = None,\n        execution_params: Optional[dict] = None,\n        transformer_params: Optional[dict] = None,\n        filters: Optional[dict | FilterBuilder] = None,\n        status: Optional[str] = None,\n    ) -&gt; Binding:\n        \"\"\"Synchronously create a new binding.\n\n        One of either `_name` or `_id` is required for `collection`. If both `_name`\n        and `_id` are provided, `_id` will be used.\n\n        Args:\n            collection_name (str): Name of the collection containing the source\n                documents.\n            collection_id (str): ID of the collection containing the source documents.\n            transformer_id (str): ID of the transformer that the binding will run.\n            index_id (str): ID of the index in which the binding will store its output.\n            description (str, optional): A description of the binding.\n            execution_params (dict, optional): Parameters to pass to the binding's\n                execution function.\n            transformer_params (dict, optional): Parameters to pass to the transformer.\n            filters (dict | FilterBuilder, optional): Filters to apply to documents in\n                the collection before running the transformer.\n            status (str, optional): The status of the binding. Defaults to \"pending\".\n\n        Returns:\n            Binding: The created binding.\n\n        Raises:\n            ValueError: If neither `_name` nor `_id` is provided for `collection`.\n\n        Examples:\n            Create a binding that runs the transformer with ID \"image.embeddings.clip\"\n            on all image documents in the collection named \"my_collection\" and stores\n            the output in the index with ID \"image_embeddings\":\n\n            &gt;&gt;&gt; from lexy_py import LexyClient, FilterBuilder\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; image_filter = FilterBuilder().include(\"meta.type\", \"equals\", \"image\")\n            &gt;&gt;&gt; binding = lx.create_binding(\n            ...     collection_name=\"my_collection\",\n            ...     transformer_id=\"image.embeddings.clip\",\n            ...     index_id=\"image_embeddings\",\n            ...     filters=image_filter\n            ... )\n        \"\"\"\n        # TODO: move execution_params and transformer_params logic to BindingCreate\n        #  model\n        if execution_params is None:\n            execution_params = {}\n        if transformer_params is None:\n            transformer_params = {}\n        binding = BindingCreate(\n            collection_name=collection_name,\n            collection_id=collection_id,\n            transformer_id=transformer_id,\n            index_id=index_id,\n            description=description,\n            execution_params=execution_params,\n            transformer_params=transformer_params,\n            filter=filters,\n            status=status,\n        )\n        r = self.client.post(\"/bindings\", json=binding.model_dump(exclude_none=True))\n        handle_response(r)\n        return Binding(**r.json()[\"binding\"], client=self._lexy_client)\n\n    async def acreate_binding(\n        self,\n        *,\n        collection_name: str = None,\n        collection_id: str = None,\n        transformer_id: str = None,\n        index_id: str = None,\n        description: Optional[str] = None,\n        execution_params: Optional[dict] = None,\n        transformer_params: Optional[dict] = None,\n        filters: Optional[dict | FilterBuilder] = None,\n        status: Optional[str] = None,\n    ) -&gt; Binding:\n        \"\"\"Asynchronously create a new binding.\n\n        One of either `_name` or `_id` is required for `collection`. If both `_name`\n        and `_id` are provided, `_id` will be used.\n\n        Args:\n            collection_name (str): Name of the collection containing the source\n                documents.\n            collection_id (str): ID of the collection containing the source documents.\n            transformer_id (str): ID of the transformer that the binding will run.\n            index_id (str): ID of the index in which the binding will store its output.\n            description (str, optional): A description of the binding.\n            execution_params (dict, optional): Parameters to pass to the binding's\n                execution function.\n            transformer_params (dict, optional): Parameters to pass to the transformer.\n            filters (dict | FilterBuilder, optional): Filters to apply to documents in\n                the collection before running the transformer.\n            status (str, optional): The status of the binding. Defaults to \"pending\".\n\n        Returns:\n            Binding: The created binding.\n\n        Raises:\n            ValueError: If neither `_name` nor `_id` is provided for `collection`.\n        \"\"\"\n        # TODO: move execution_params and transformer_params logic to BindingCreate\n        #  model\n        if execution_params is None:\n            execution_params = {}\n        if transformer_params is None:\n            transformer_params = {}\n        binding = BindingCreate(\n            collection_name=collection_name,\n            collection_id=collection_id,\n            transformer_id=transformer_id,\n            index_id=index_id,\n            description=description,\n            execution_params=execution_params,\n            transformer_params=transformer_params,\n            filter=filters,\n            status=status,\n        )\n        r = await self.aclient.post(\n            \"/bindings\", json=binding.model_dump(exclude_none=True)\n        )\n        handle_response(r)\n        return Binding(**r.json()[\"binding\"], client=self._lexy_client)\n\n    def get_binding(self, binding_id: int) -&gt; Binding:\n        \"\"\"Synchronously get a binding.\n\n        Args:\n            binding_id (int): The ID of the binding to get.\n\n        Returns:\n            Binding: The binding.\n        \"\"\"\n        r = self.client.get(f\"/bindings/{binding_id}\")\n        handle_response(r)\n        return Binding(**r.json(), client=self._lexy_client)\n\n    async def aget_binding(self, binding_id: int) -&gt; Binding:\n        \"\"\"Asynchronously get a binding.\n\n        Args:\n            binding_id (int): The ID of the binding to get.\n\n        Returns:\n            Binding: The binding.\n        \"\"\"\n        r = await self.aclient.get(f\"/bindings/{binding_id}\")\n        handle_response(r)\n        return Binding(**r.json(), client=self._lexy_client)\n\n    def update_binding(\n        self,\n        binding_id: int,\n        *,\n        description: Optional[str] = None,\n        execution_params: Optional[dict] = None,\n        transformer_params: Optional[dict] = None,\n        filters: Optional[dict | FilterBuilder] = None,\n        status: Optional[str] = None,\n    ) -&gt; Binding:\n        \"\"\"Synchronously update a binding.\n\n        Args:\n            binding_id (int): The ID of the binding to update.\n            description (str, optional): A description of the binding.\n            execution_params (dict, optional): Parameters to pass to the binding's\n                execution function.\n            transformer_params (dict, optional): Parameters to pass to the transformer.\n            filters (dict | FilterBuilder, optional): Filters to apply to documents in\n                the collection before running the transformer. Set to an empty dict to\n                remove any existing filter.\n            status (str, optional): The status of the binding.\n\n        Returns:\n            Binding: The updated binding.\n        \"\"\"\n        binding = BindingUpdate(\n            description=description,\n            execution_params=execution_params,\n            transformer_params=transformer_params,\n            filter=filters,\n            status=status,\n        )\n        json_payload = binding.model_dump(exclude_none=True)\n        if json_payload[\"filter\"] == {}:  # explicitly removed filters\n            json_payload[\"filter\"] = None\n        r = self.client.patch(f\"/bindings/{binding_id}\", json=json_payload)\n        handle_response(r)\n        return Binding(**r.json()[\"binding\"], client=self._lexy_client)\n\n    async def aupdate_binding(\n        self,\n        *,\n        binding_id: int,\n        description: Optional[str] = None,\n        execution_params: Optional[dict] = None,\n        transformer_params: Optional[dict] = None,\n        filters: Optional[dict | FilterBuilder] = None,\n        status: Optional[str] = None,\n    ) -&gt; Binding:\n        \"\"\"Asynchronously update a binding.\n\n        Args:\n            binding_id (int): The ID of the binding to update.\n            description (str, optional): A description of the binding.\n            execution_params (dict, optional): Parameters to pass to the binding's\n                execution function.\n            transformer_params (dict, optional): Parameters to pass to the transformer.\n            filters (dict | FilterBuilder, optional): Filters to apply to documents in\n                the collection before running the transformer. Set to an empty dict to\n                remove any existing filter.\n            status (str, optional): The status of the binding.\n\n        Returns:\n            Binding: The updated binding.\n        \"\"\"\n        binding = BindingUpdate(\n            description=description,\n            execution_params=execution_params,\n            transformer_params=transformer_params,\n            filter=filters,\n            status=status,\n        )\n        json_payload = binding.model_dump(exclude_none=True)\n        if json_payload[\"filter\"] == {}:  # explicitly removed filters\n            json_payload[\"filter\"] = None\n        r = await self.aclient.patch(f\"/bindings/{binding_id}\", json=json_payload)\n        handle_response(r)\n        return Binding(**r.json()[\"binding\"], client=self._lexy_client)\n\n    def delete_binding(self, binding_id: int) -&gt; dict:\n        \"\"\"Synchronously delete a binding.\n\n        Args:\n            binding_id (int): The ID of the binding to delete.\n        \"\"\"\n        r = self.client.delete(f\"/bindings/{binding_id}\")\n        handle_response(r)\n        return r.json()\n\n    async def adelete_binding(self, binding_id: int) -&gt; dict:\n        \"\"\"Asynchronously delete a binding.\n\n        Args:\n            binding_id (int): The ID of the binding to delete.\n        \"\"\"\n        r = await self.aclient.delete(f\"/bindings/{binding_id}\")\n        handle_response(r)\n        return r.json()\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.create_binding","title":"<code>create_binding(*, collection_name=None, collection_id=None, transformer_id=None, index_id=None, description=None, execution_params=None, transformer_params=None, filters=None, status=None)</code>","text":"<p>Synchronously create a new binding.</p> <p>One of either <code>_name</code> or <code>_id</code> is required for <code>collection</code>. If both <code>_name</code> and <code>_id</code> are provided, <code>_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>Name of the collection containing the source documents.</p> <code>None</code> <code>collection_id</code> <code>str</code> <p>ID of the collection containing the source documents.</p> <code>None</code> <code>transformer_id</code> <code>str</code> <p>ID of the transformer that the binding will run.</p> <code>None</code> <code>index_id</code> <code>str</code> <p>ID of the index in which the binding will store its output.</p> <code>None</code> <code>description</code> <code>str</code> <p>A description of the binding.</p> <code>None</code> <code>execution_params</code> <code>dict</code> <p>Parameters to pass to the binding's execution function.</p> <code>None</code> <code>transformer_params</code> <code>dict</code> <p>Parameters to pass to the transformer.</p> <code>None</code> <code>filters</code> <code>dict | FilterBuilder</code> <p>Filters to apply to documents in the collection before running the transformer.</p> <code>None</code> <code>status</code> <code>str</code> <p>The status of the binding. Defaults to \"pending\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Binding</code> <code>Binding</code> <p>The created binding.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>_name</code> nor <code>_id</code> is provided for <code>collection</code>.</p> <p>Examples:</p> <p>Create a binding that runs the transformer with ID \"image.embeddings.clip\" on all image documents in the collection named \"my_collection\" and stores the output in the index with ID \"image_embeddings\":</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient, FilterBuilder\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; image_filter = FilterBuilder().include(\"meta.type\", \"equals\", \"image\")\n&gt;&gt;&gt; binding = lx.create_binding(\n...     collection_name=\"my_collection\",\n...     transformer_id=\"image.embeddings.clip\",\n...     index_id=\"image_embeddings\",\n...     filters=image_filter\n... )\n</code></pre> Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>def create_binding(\n    self,\n    *,\n    collection_name: str = None,\n    collection_id: str = None,\n    transformer_id: str = None,\n    index_id: str = None,\n    description: Optional[str] = None,\n    execution_params: Optional[dict] = None,\n    transformer_params: Optional[dict] = None,\n    filters: Optional[dict | FilterBuilder] = None,\n    status: Optional[str] = None,\n) -&gt; Binding:\n    \"\"\"Synchronously create a new binding.\n\n    One of either `_name` or `_id` is required for `collection`. If both `_name`\n    and `_id` are provided, `_id` will be used.\n\n    Args:\n        collection_name (str): Name of the collection containing the source\n            documents.\n        collection_id (str): ID of the collection containing the source documents.\n        transformer_id (str): ID of the transformer that the binding will run.\n        index_id (str): ID of the index in which the binding will store its output.\n        description (str, optional): A description of the binding.\n        execution_params (dict, optional): Parameters to pass to the binding's\n            execution function.\n        transformer_params (dict, optional): Parameters to pass to the transformer.\n        filters (dict | FilterBuilder, optional): Filters to apply to documents in\n            the collection before running the transformer.\n        status (str, optional): The status of the binding. Defaults to \"pending\".\n\n    Returns:\n        Binding: The created binding.\n\n    Raises:\n        ValueError: If neither `_name` nor `_id` is provided for `collection`.\n\n    Examples:\n        Create a binding that runs the transformer with ID \"image.embeddings.clip\"\n        on all image documents in the collection named \"my_collection\" and stores\n        the output in the index with ID \"image_embeddings\":\n\n        &gt;&gt;&gt; from lexy_py import LexyClient, FilterBuilder\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; image_filter = FilterBuilder().include(\"meta.type\", \"equals\", \"image\")\n        &gt;&gt;&gt; binding = lx.create_binding(\n        ...     collection_name=\"my_collection\",\n        ...     transformer_id=\"image.embeddings.clip\",\n        ...     index_id=\"image_embeddings\",\n        ...     filters=image_filter\n        ... )\n    \"\"\"\n    # TODO: move execution_params and transformer_params logic to BindingCreate\n    #  model\n    if execution_params is None:\n        execution_params = {}\n    if transformer_params is None:\n        transformer_params = {}\n    binding = BindingCreate(\n        collection_name=collection_name,\n        collection_id=collection_id,\n        transformer_id=transformer_id,\n        index_id=index_id,\n        description=description,\n        execution_params=execution_params,\n        transformer_params=transformer_params,\n        filter=filters,\n        status=status,\n    )\n    r = self.client.post(\"/bindings\", json=binding.model_dump(exclude_none=True))\n    handle_response(r)\n    return Binding(**r.json()[\"binding\"], client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.delete_binding","title":"<code>delete_binding(binding_id)</code>","text":"<p>Synchronously delete a binding.</p> <p>Parameters:</p> Name Type Description Default <code>binding_id</code> <code>int</code> <p>The ID of the binding to delete.</p> required Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>def delete_binding(self, binding_id: int) -&gt; dict:\n    \"\"\"Synchronously delete a binding.\n\n    Args:\n        binding_id (int): The ID of the binding to delete.\n    \"\"\"\n    r = self.client.delete(f\"/bindings/{binding_id}\")\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.get_binding","title":"<code>get_binding(binding_id)</code>","text":"<p>Synchronously get a binding.</p> <p>Parameters:</p> Name Type Description Default <code>binding_id</code> <code>int</code> <p>The ID of the binding to get.</p> required <p>Returns:</p> Name Type Description <code>Binding</code> <code>Binding</code> <p>The binding.</p> Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>def get_binding(self, binding_id: int) -&gt; Binding:\n    \"\"\"Synchronously get a binding.\n\n    Args:\n        binding_id (int): The ID of the binding to get.\n\n    Returns:\n        Binding: The binding.\n    \"\"\"\n    r = self.client.get(f\"/bindings/{binding_id}\")\n    handle_response(r)\n    return Binding(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.list_bindings","title":"<code>list_bindings()</code>","text":"<p>Synchronously get a list of all bindings.</p> <p>Returns:</p> Type Description <code>list[Binding]</code> <p>list[Binding]: A list of all bindings.</p> Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>def list_bindings(self) -&gt; list[Binding]:\n    \"\"\"Synchronously get a list of all bindings.\n\n    Returns:\n        list[Binding]: A list of all bindings.\n    \"\"\"\n    r = self.client.get(\"/bindings\")\n    handle_response(r)\n    return [Binding(**binding, client=self._lexy_client) for binding in r.json()]\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.update_binding","title":"<code>update_binding(binding_id, *, description=None, execution_params=None, transformer_params=None, filters=None, status=None)</code>","text":"<p>Synchronously update a binding.</p> <p>Parameters:</p> Name Type Description Default <code>binding_id</code> <code>int</code> <p>The ID of the binding to update.</p> required <code>description</code> <code>str</code> <p>A description of the binding.</p> <code>None</code> <code>execution_params</code> <code>dict</code> <p>Parameters to pass to the binding's execution function.</p> <code>None</code> <code>transformer_params</code> <code>dict</code> <p>Parameters to pass to the transformer.</p> <code>None</code> <code>filters</code> <code>dict | FilterBuilder</code> <p>Filters to apply to documents in the collection before running the transformer. Set to an empty dict to remove any existing filter.</p> <code>None</code> <code>status</code> <code>str</code> <p>The status of the binding.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Binding</code> <code>Binding</code> <p>The updated binding.</p> Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>def update_binding(\n    self,\n    binding_id: int,\n    *,\n    description: Optional[str] = None,\n    execution_params: Optional[dict] = None,\n    transformer_params: Optional[dict] = None,\n    filters: Optional[dict | FilterBuilder] = None,\n    status: Optional[str] = None,\n) -&gt; Binding:\n    \"\"\"Synchronously update a binding.\n\n    Args:\n        binding_id (int): The ID of the binding to update.\n        description (str, optional): A description of the binding.\n        execution_params (dict, optional): Parameters to pass to the binding's\n            execution function.\n        transformer_params (dict, optional): Parameters to pass to the transformer.\n        filters (dict | FilterBuilder, optional): Filters to apply to documents in\n            the collection before running the transformer. Set to an empty dict to\n            remove any existing filter.\n        status (str, optional): The status of the binding.\n\n    Returns:\n        Binding: The updated binding.\n    \"\"\"\n    binding = BindingUpdate(\n        description=description,\n        execution_params=execution_params,\n        transformer_params=transformer_params,\n        filter=filters,\n        status=status,\n    )\n    json_payload = binding.model_dump(exclude_none=True)\n    if json_payload[\"filter\"] == {}:  # explicitly removed filters\n        json_payload[\"filter\"] = None\n    r = self.client.patch(f\"/bindings/{binding_id}\", json=json_payload)\n    handle_response(r)\n    return Binding(**r.json()[\"binding\"], client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.acreate_binding","title":"<code>acreate_binding(*, collection_name=None, collection_id=None, transformer_id=None, index_id=None, description=None, execution_params=None, transformer_params=None, filters=None, status=None)</code>  <code>async</code>","text":"<p>Asynchronously create a new binding.</p> <p>One of either <code>_name</code> or <code>_id</code> is required for <code>collection</code>. If both <code>_name</code> and <code>_id</code> are provided, <code>_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>Name of the collection containing the source documents.</p> <code>None</code> <code>collection_id</code> <code>str</code> <p>ID of the collection containing the source documents.</p> <code>None</code> <code>transformer_id</code> <code>str</code> <p>ID of the transformer that the binding will run.</p> <code>None</code> <code>index_id</code> <code>str</code> <p>ID of the index in which the binding will store its output.</p> <code>None</code> <code>description</code> <code>str</code> <p>A description of the binding.</p> <code>None</code> <code>execution_params</code> <code>dict</code> <p>Parameters to pass to the binding's execution function.</p> <code>None</code> <code>transformer_params</code> <code>dict</code> <p>Parameters to pass to the transformer.</p> <code>None</code> <code>filters</code> <code>dict | FilterBuilder</code> <p>Filters to apply to documents in the collection before running the transformer.</p> <code>None</code> <code>status</code> <code>str</code> <p>The status of the binding. Defaults to \"pending\".</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Binding</code> <code>Binding</code> <p>The created binding.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>_name</code> nor <code>_id</code> is provided for <code>collection</code>.</p> Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>async def acreate_binding(\n    self,\n    *,\n    collection_name: str = None,\n    collection_id: str = None,\n    transformer_id: str = None,\n    index_id: str = None,\n    description: Optional[str] = None,\n    execution_params: Optional[dict] = None,\n    transformer_params: Optional[dict] = None,\n    filters: Optional[dict | FilterBuilder] = None,\n    status: Optional[str] = None,\n) -&gt; Binding:\n    \"\"\"Asynchronously create a new binding.\n\n    One of either `_name` or `_id` is required for `collection`. If both `_name`\n    and `_id` are provided, `_id` will be used.\n\n    Args:\n        collection_name (str): Name of the collection containing the source\n            documents.\n        collection_id (str): ID of the collection containing the source documents.\n        transformer_id (str): ID of the transformer that the binding will run.\n        index_id (str): ID of the index in which the binding will store its output.\n        description (str, optional): A description of the binding.\n        execution_params (dict, optional): Parameters to pass to the binding's\n            execution function.\n        transformer_params (dict, optional): Parameters to pass to the transformer.\n        filters (dict | FilterBuilder, optional): Filters to apply to documents in\n            the collection before running the transformer.\n        status (str, optional): The status of the binding. Defaults to \"pending\".\n\n    Returns:\n        Binding: The created binding.\n\n    Raises:\n        ValueError: If neither `_name` nor `_id` is provided for `collection`.\n    \"\"\"\n    # TODO: move execution_params and transformer_params logic to BindingCreate\n    #  model\n    if execution_params is None:\n        execution_params = {}\n    if transformer_params is None:\n        transformer_params = {}\n    binding = BindingCreate(\n        collection_name=collection_name,\n        collection_id=collection_id,\n        transformer_id=transformer_id,\n        index_id=index_id,\n        description=description,\n        execution_params=execution_params,\n        transformer_params=transformer_params,\n        filter=filters,\n        status=status,\n    )\n    r = await self.aclient.post(\n        \"/bindings\", json=binding.model_dump(exclude_none=True)\n    )\n    handle_response(r)\n    return Binding(**r.json()[\"binding\"], client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.adelete_binding","title":"<code>adelete_binding(binding_id)</code>  <code>async</code>","text":"<p>Asynchronously delete a binding.</p> <p>Parameters:</p> Name Type Description Default <code>binding_id</code> <code>int</code> <p>The ID of the binding to delete.</p> required Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>async def adelete_binding(self, binding_id: int) -&gt; dict:\n    \"\"\"Asynchronously delete a binding.\n\n    Args:\n        binding_id (int): The ID of the binding to delete.\n    \"\"\"\n    r = await self.aclient.delete(f\"/bindings/{binding_id}\")\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.aget_binding","title":"<code>aget_binding(binding_id)</code>  <code>async</code>","text":"<p>Asynchronously get a binding.</p> <p>Parameters:</p> Name Type Description Default <code>binding_id</code> <code>int</code> <p>The ID of the binding to get.</p> required <p>Returns:</p> Name Type Description <code>Binding</code> <code>Binding</code> <p>The binding.</p> Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>async def aget_binding(self, binding_id: int) -&gt; Binding:\n    \"\"\"Asynchronously get a binding.\n\n    Args:\n        binding_id (int): The ID of the binding to get.\n\n    Returns:\n        Binding: The binding.\n    \"\"\"\n    r = await self.aclient.get(f\"/bindings/{binding_id}\")\n    handle_response(r)\n    return Binding(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.alist_bindings","title":"<code>alist_bindings()</code>  <code>async</code>","text":"<p>Asynchronously get a list of all bindings.</p> <p>Returns:</p> Type Description <code>list[Binding]</code> <p>list[Binding]: A list of all bindings.</p> Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>async def alist_bindings(self) -&gt; list[Binding]:\n    \"\"\"Asynchronously get a list of all bindings.\n\n    Returns:\n        list[Binding]: A list of all bindings.\n    \"\"\"\n    r = await self.aclient.get(\"/bindings\")\n    handle_response(r)\n    return [Binding(**binding, client=self._lexy_client) for binding in r.json()]\n</code></pre>"},{"location":"reference/lexy_py/binding/#lexy_py.binding.client.BindingClient.aupdate_binding","title":"<code>aupdate_binding(*, binding_id, description=None, execution_params=None, transformer_params=None, filters=None, status=None)</code>  <code>async</code>","text":"<p>Asynchronously update a binding.</p> <p>Parameters:</p> Name Type Description Default <code>binding_id</code> <code>int</code> <p>The ID of the binding to update.</p> required <code>description</code> <code>str</code> <p>A description of the binding.</p> <code>None</code> <code>execution_params</code> <code>dict</code> <p>Parameters to pass to the binding's execution function.</p> <code>None</code> <code>transformer_params</code> <code>dict</code> <p>Parameters to pass to the transformer.</p> <code>None</code> <code>filters</code> <code>dict | FilterBuilder</code> <p>Filters to apply to documents in the collection before running the transformer. Set to an empty dict to remove any existing filter.</p> <code>None</code> <code>status</code> <code>str</code> <p>The status of the binding.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Binding</code> <code>Binding</code> <p>The updated binding.</p> Source code in <code>sdk-python/lexy_py/binding/client.py</code> <pre><code>async def aupdate_binding(\n    self,\n    *,\n    binding_id: int,\n    description: Optional[str] = None,\n    execution_params: Optional[dict] = None,\n    transformer_params: Optional[dict] = None,\n    filters: Optional[dict | FilterBuilder] = None,\n    status: Optional[str] = None,\n) -&gt; Binding:\n    \"\"\"Asynchronously update a binding.\n\n    Args:\n        binding_id (int): The ID of the binding to update.\n        description (str, optional): A description of the binding.\n        execution_params (dict, optional): Parameters to pass to the binding's\n            execution function.\n        transformer_params (dict, optional): Parameters to pass to the transformer.\n        filters (dict | FilterBuilder, optional): Filters to apply to documents in\n            the collection before running the transformer. Set to an empty dict to\n            remove any existing filter.\n        status (str, optional): The status of the binding.\n\n    Returns:\n        Binding: The updated binding.\n    \"\"\"\n    binding = BindingUpdate(\n        description=description,\n        execution_params=execution_params,\n        transformer_params=transformer_params,\n        filter=filters,\n        status=status,\n    )\n    json_payload = binding.model_dump(exclude_none=True)\n    if json_payload[\"filter\"] == {}:  # explicitly removed filters\n        json_payload[\"filter\"] = None\n    r = await self.aclient.patch(f\"/bindings/{binding_id}\", json=json_payload)\n    handle_response(r)\n    return Binding(**r.json()[\"binding\"], client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/client/","title":"Documentation for <code>LexyClient</code>","text":""},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient","title":"<code>lexy_py.client.LexyClient</code>","text":"<p>LexyClient class</p> <p>Attributes:</p> Name Type Description <code>base_url</code> <code>str</code> <p>Base URL for the Lexy API.</p> <code>aclient</code> <code>AsyncClient</code> <p>Asynchronous API client.</p> <code>client</code> <code>Client</code> <p>Synchronous API client.</p> <code>binding</code> <code>BindingClient</code> <p>Client for interacting with the Bindings API.</p> <code>collection</code> <code>CollectionClient</code> <p>Client for interacting with the Collections API.</p> <code>document</code> <code>DocumentClient</code> <p>Client for interacting with the Documents API.</p> <code>index</code> <code>IndexClient</code> <p>Client for interacting with the Indexes API.</p> <code>transformer</code> <code>TransformerClient</code> <p>Client for interacting with the Transformers API.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>class LexyClient:\n    \"\"\"\n    LexyClient class\n\n    Attributes:\n        base_url (str): Base URL for the Lexy API.\n        aclient (httpx.AsyncClient): Asynchronous API client.\n        client (httpx.Client): Synchronous API client.\n        binding (BindingClient): Client for interacting with the Bindings API.\n        collection (CollectionClient): Client for interacting with the Collections API.\n        document (DocumentClient): Client for interacting with the Documents API.\n        index (IndexClient): Client for interacting with the Indexes API.\n        transformer (TransformerClient): Client for interacting with the Transformers\n            API.\n    \"\"\"\n\n    base_url: str\n    aclient: httpx.AsyncClient\n    client: httpx.Client\n\n    binding: BindingClient\n    collection: CollectionClient\n    document: DocumentClient\n    index: IndexClient\n    transformer: TransformerClient\n\n    def __init__(\n        self,\n        base_url: str = DEFAULT_BASE_URL,\n        api_timeout: int = API_TIMEOUT,\n        client_kwargs: dict = None,\n        aclient_kwargs: dict = None,\n    ) -&gt; None:\n        \"\"\"Initialize a LexyClient instance.\n\n        Args:\n            base_url (str, optional): Base URL for the Lexy API. Defaults to\n                DEFAULT_BASE_URL.\n            api_timeout (int, optional): Timeout in seconds for API requests. Defaults\n                to API_TIMEOUT.\n            client_kwargs (dict, optional): Keyword args for the synchronous API client.\n            aclient_kwargs (dict, optional): Keyword args for the asynchronous API\n                client.\n        \"\"\"\n        self.base_url = base_url\n        self.api_timeout = api_timeout\n\n        client_kwargs = client_kwargs or {}\n        self._client = httpx.Client(\n            base_url=self.base_url, timeout=self.api_timeout, **client_kwargs\n        )\n        aclient_kwargs = aclient_kwargs or {}\n        self._aclient = httpx.AsyncClient(\n            base_url=self.base_url, timeout=self.api_timeout, **aclient_kwargs\n        )\n\n        # binding\n        self.binding = BindingClient(self)\n        self.create_binding = self.binding.create_binding\n        self.delete_binding = self.binding.delete_binding\n        self.get_binding = self.binding.get_binding\n        self.list_bindings = self.binding.list_bindings\n        self.update_binding = self.binding.update_binding\n\n        # collection\n        self.collection = CollectionClient(self)\n        self.create_collection = self.collection.create_collection\n        self.delete_collection = self.collection.delete_collection\n        self.get_collection = self.collection.get_collection\n        self.list_collections = self.collection.list_collections\n        self.update_collection = self.collection.update_collection\n\n        # document\n        self.document = DocumentClient(self)\n        self.add_documents = self.document.add_documents\n        self.bulk_delete_documents = self.document.bulk_delete_documents\n        self.delete_document = self.document.delete_document\n        self.get_document = self.document.get_document\n        self.list_documents = self.document.list_documents\n        self.update_document = self.document.update_document\n        self.upload_documents = self.document.upload_documents\n\n        # index\n        self.index = IndexClient(self)\n        self.create_index = self.index.create_index\n        self.delete_index = self.index.delete_index\n        self.get_index = self.index.get_index\n        self.list_indexes = self.index.list_indexes\n        self.query_index = self.index.query_index\n        self.update_index = self.index.update_index\n\n        # transformer\n        self.transformer = TransformerClient(self)\n        self.create_transformer = self.transformer.create_transformer\n        self.delete_transformer = self.transformer.delete_transformer\n        self.get_transformer = self.transformer.get_transformer\n        self.list_transformers = self.transformer.list_transformers\n        self.update_transformer = self.transformer.update_transformer\n        self.transform_document = self.transformer.transform_document\n\n    @property\n    def client(self) -&gt; httpx.Client:\n        if self._client is None:\n            raise LexyClientError(\"Client is not set.\")\n        return self._client\n\n    @client.setter\n    def client(self, value) -&gt; None:\n        self._client = value\n\n    @property\n    def aclient(self) -&gt; httpx.AsyncClient:\n        if self._aclient is None:\n            raise LexyClientError(\"AsyncClient is not set.\")\n        return self._aclient\n\n    @aclient.setter\n    def aclient(self, value) -&gt; None:\n        self._aclient = value\n\n    async def __aenter__(self) -&gt; \"LexyClient\":\n        \"\"\"Async context manager entry point.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb) -&gt; None:\n        \"\"\"Async context manager exit point.\"\"\"\n        await self.aclient.aclose()\n\n    def __enter__(self) -&gt; \"LexyClient\":\n        \"\"\"Synchronous context manager entry point.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc, tb) -&gt; None:\n        \"\"\"Synchronous context manager exit point.\"\"\"\n        self.client.close()\n\n    def get(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"Synchronous GET request.\"\"\"\n        return self.client.get(url, **kwargs)\n\n    async def aget(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"Async GET request.\"\"\"\n        return await self.aclient.get(url, **kwargs)\n\n    def post(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"Synchronous POST request.\"\"\"\n        return self.client.post(url, **kwargs)\n\n    async def apost(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"Async POST request.\"\"\"\n        return await self.aclient.post(url, **kwargs)\n\n    def patch(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"Synchronous PATCH request.\"\"\"\n        return self.client.patch(url, **kwargs)\n\n    async def apatch(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"Async PATCH request.\"\"\"\n        return await self.aclient.patch(url, **kwargs)\n\n    def delete(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"Synchronous DELETE request.\"\"\"\n        return self.client.delete(url, **kwargs)\n\n    async def adelete(self, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"Async DELETE request.\"\"\"\n        return await self.aclient.delete(url, **kwargs)\n\n    @property\n    def bindings(self):\n        \"\"\"Get a list of all bindings.\"\"\"\n        return self.binding.list_bindings()\n\n    @property\n    def collections(self):\n        \"\"\"Get a list of all collections.\"\"\"\n        return self.collection.list_collections()\n\n    @property\n    def indexes(self):\n        \"\"\"Get a list of all indexes.\"\"\"\n        return self.index.list_indexes()\n\n    @property\n    def transformers(self):\n        \"\"\"Get a list of all transformers.\"\"\"\n        return self.transformer.list_transformers()\n\n    def info(self):\n        \"\"\"Print info about the Lexy server.\"\"\"\n        collections_str = \"\\n\".join([f\"\\t- {c.__repr__()}\" for c in self.collections])\n        indexes_str = \"\\n\".join([f\"\\t- {i.__repr__()}\" for i in self.indexes])\n        transformers_str = \"\\n\".join([f\"\\t- {t.__repr__()}\" for t in self.transformers])\n        bindings_str = \"\\n\".join([f\"\\t- {b.__repr__()}\" for b in self.bindings])\n        info_str = (\n            f\"Lexy server &lt;{self.base_url}&gt;\\n\\n\"\n            f\"{len(self.collections)} Collections\\n{collections_str}\\n\"\n            f\"{len(self.indexes)} Indexes\\n{indexes_str}\\n\"\n            f\"{len(self.transformers)} Transformers\\n{transformers_str}\\n\"\n            f\"{len(self.bindings)} Bindings\\n{bindings_str}\\n\"\n        )\n        print(info_str)\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.bindings","title":"<code>bindings</code>  <code>property</code>","text":"<p>Get a list of all bindings.</p>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.collections","title":"<code>collections</code>  <code>property</code>","text":"<p>Get a list of all collections.</p>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.indexes","title":"<code>indexes</code>  <code>property</code>","text":"<p>Get a list of all indexes.</p>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.transformers","title":"<code>transformers</code>  <code>property</code>","text":"<p>Get a list of all transformers.</p>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.__init__","title":"<code>__init__(base_url=DEFAULT_BASE_URL, api_timeout=API_TIMEOUT, client_kwargs=None, aclient_kwargs=None)</code>","text":"<p>Initialize a LexyClient instance.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL for the Lexy API. Defaults to DEFAULT_BASE_URL.</p> <code>DEFAULT_BASE_URL</code> <code>api_timeout</code> <code>int</code> <p>Timeout in seconds for API requests. Defaults to API_TIMEOUT.</p> <code>API_TIMEOUT</code> <code>client_kwargs</code> <code>dict</code> <p>Keyword args for the synchronous API client.</p> <code>None</code> <code>aclient_kwargs</code> <code>dict</code> <p>Keyword args for the asynchronous API client.</p> <code>None</code> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>def __init__(\n    self,\n    base_url: str = DEFAULT_BASE_URL,\n    api_timeout: int = API_TIMEOUT,\n    client_kwargs: dict = None,\n    aclient_kwargs: dict = None,\n) -&gt; None:\n    \"\"\"Initialize a LexyClient instance.\n\n    Args:\n        base_url (str, optional): Base URL for the Lexy API. Defaults to\n            DEFAULT_BASE_URL.\n        api_timeout (int, optional): Timeout in seconds for API requests. Defaults\n            to API_TIMEOUT.\n        client_kwargs (dict, optional): Keyword args for the synchronous API client.\n        aclient_kwargs (dict, optional): Keyword args for the asynchronous API\n            client.\n    \"\"\"\n    self.base_url = base_url\n    self.api_timeout = api_timeout\n\n    client_kwargs = client_kwargs or {}\n    self._client = httpx.Client(\n        base_url=self.base_url, timeout=self.api_timeout, **client_kwargs\n    )\n    aclient_kwargs = aclient_kwargs or {}\n    self._aclient = httpx.AsyncClient(\n        base_url=self.base_url, timeout=self.api_timeout, **aclient_kwargs\n    )\n\n    # binding\n    self.binding = BindingClient(self)\n    self.create_binding = self.binding.create_binding\n    self.delete_binding = self.binding.delete_binding\n    self.get_binding = self.binding.get_binding\n    self.list_bindings = self.binding.list_bindings\n    self.update_binding = self.binding.update_binding\n\n    # collection\n    self.collection = CollectionClient(self)\n    self.create_collection = self.collection.create_collection\n    self.delete_collection = self.collection.delete_collection\n    self.get_collection = self.collection.get_collection\n    self.list_collections = self.collection.list_collections\n    self.update_collection = self.collection.update_collection\n\n    # document\n    self.document = DocumentClient(self)\n    self.add_documents = self.document.add_documents\n    self.bulk_delete_documents = self.document.bulk_delete_documents\n    self.delete_document = self.document.delete_document\n    self.get_document = self.document.get_document\n    self.list_documents = self.document.list_documents\n    self.update_document = self.document.update_document\n    self.upload_documents = self.document.upload_documents\n\n    # index\n    self.index = IndexClient(self)\n    self.create_index = self.index.create_index\n    self.delete_index = self.index.delete_index\n    self.get_index = self.index.get_index\n    self.list_indexes = self.index.list_indexes\n    self.query_index = self.index.query_index\n    self.update_index = self.index.update_index\n\n    # transformer\n    self.transformer = TransformerClient(self)\n    self.create_transformer = self.transformer.create_transformer\n    self.delete_transformer = self.transformer.delete_transformer\n    self.get_transformer = self.transformer.get_transformer\n    self.list_transformers = self.transformer.list_transformers\n    self.update_transformer = self.transformer.update_transformer\n    self.transform_document = self.transformer.transform_document\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.adelete","title":"<code>adelete(url, **kwargs)</code>  <code>async</code>","text":"<p>Async DELETE request.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>async def adelete(self, url: str, **kwargs) -&gt; httpx.Response:\n    \"\"\"Async DELETE request.\"\"\"\n    return await self.aclient.delete(url, **kwargs)\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.aget","title":"<code>aget(url, **kwargs)</code>  <code>async</code>","text":"<p>Async GET request.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>async def aget(self, url: str, **kwargs) -&gt; httpx.Response:\n    \"\"\"Async GET request.\"\"\"\n    return await self.aclient.get(url, **kwargs)\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.apatch","title":"<code>apatch(url, **kwargs)</code>  <code>async</code>","text":"<p>Async PATCH request.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>async def apatch(self, url: str, **kwargs) -&gt; httpx.Response:\n    \"\"\"Async PATCH request.\"\"\"\n    return await self.aclient.patch(url, **kwargs)\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.apost","title":"<code>apost(url, **kwargs)</code>  <code>async</code>","text":"<p>Async POST request.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>async def apost(self, url: str, **kwargs) -&gt; httpx.Response:\n    \"\"\"Async POST request.\"\"\"\n    return await self.aclient.post(url, **kwargs)\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.delete","title":"<code>delete(url, **kwargs)</code>","text":"<p>Synchronous DELETE request.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>def delete(self, url: str, **kwargs) -&gt; httpx.Response:\n    \"\"\"Synchronous DELETE request.\"\"\"\n    return self.client.delete(url, **kwargs)\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.get","title":"<code>get(url, **kwargs)</code>","text":"<p>Synchronous GET request.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>def get(self, url: str, **kwargs) -&gt; httpx.Response:\n    \"\"\"Synchronous GET request.\"\"\"\n    return self.client.get(url, **kwargs)\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.info","title":"<code>info()</code>","text":"<p>Print info about the Lexy server.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>def info(self):\n    \"\"\"Print info about the Lexy server.\"\"\"\n    collections_str = \"\\n\".join([f\"\\t- {c.__repr__()}\" for c in self.collections])\n    indexes_str = \"\\n\".join([f\"\\t- {i.__repr__()}\" for i in self.indexes])\n    transformers_str = \"\\n\".join([f\"\\t- {t.__repr__()}\" for t in self.transformers])\n    bindings_str = \"\\n\".join([f\"\\t- {b.__repr__()}\" for b in self.bindings])\n    info_str = (\n        f\"Lexy server &lt;{self.base_url}&gt;\\n\\n\"\n        f\"{len(self.collections)} Collections\\n{collections_str}\\n\"\n        f\"{len(self.indexes)} Indexes\\n{indexes_str}\\n\"\n        f\"{len(self.transformers)} Transformers\\n{transformers_str}\\n\"\n        f\"{len(self.bindings)} Bindings\\n{bindings_str}\\n\"\n    )\n    print(info_str)\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.patch","title":"<code>patch(url, **kwargs)</code>","text":"<p>Synchronous PATCH request.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>def patch(self, url: str, **kwargs) -&gt; httpx.Response:\n    \"\"\"Synchronous PATCH request.\"\"\"\n    return self.client.patch(url, **kwargs)\n</code></pre>"},{"location":"reference/lexy_py/client/#lexy_py.client.LexyClient.post","title":"<code>post(url, **kwargs)</code>","text":"<p>Synchronous POST request.</p> Source code in <code>sdk-python/lexy_py/client.py</code> <pre><code>def post(self, url: str, **kwargs) -&gt; httpx.Response:\n    \"\"\"Synchronous POST request.\"\"\"\n    return self.client.post(url, **kwargs)\n</code></pre>"},{"location":"reference/lexy_py/collection/","title":"Documentation for <code>Collection</code>","text":""},{"location":"reference/lexy_py/collection/#lexy_py.collection.models.Collection","title":"<code>lexy_py.collection.models.Collection</code>","text":"<p>             Bases: <code>CollectionModel</code></p> <p>Collection model</p> Source code in <code>sdk-python/lexy_py/collection/models.py</code> <pre><code>class Collection(CollectionModel):\n    __doc__ = CollectionModel.__doc__\n    _client: Optional[\"LexyClient\"] = PrivateAttr(default=None)\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        self._client = data.pop(\"client\", None)\n\n    @property\n    def client(self) -&gt; \"LexyClient\":\n        if not self._client:\n            raise ValueError(\"API client has not been set.\")\n        return self._client\n\n    def add_documents(\n        self, docs: Document | dict | list[Document | dict], *, batch_size: int = 100\n    ) -&gt; list[Document]:\n        \"\"\"Synchronously add documents to the collection in batches.\n\n        Args:\n            docs (Document | dict | list[Document | dict]): The documents to add.\n            batch_size (int): The number of documents to add in each batch. Defaults\n                to 100.\n\n        Returns:\n            Documents: A list of created documents.\n        \"\"\"\n        return self.client.document.add_documents(\n            docs, collection_id=self.collection_id, batch_size=batch_size\n        )\n\n    # TODO: add pagination\n    def list_documents(self, *, limit: int = 100, offset: int = 0) -&gt; list[Document]:\n        \"\"\"Synchronously get a list of documents in the collection.\n\n        Args:\n            limit (int): The maximum number of documents to return. Defaults to 100.\n                Maximum allowed is 1000.\n            offset (int): The offset to start from. Defaults to 0.\n\n        Returns:\n            Documents: A list of documents in the collection.\n        \"\"\"\n        return self.client.document.list_documents(\n            collection_id=self.collection_id, limit=limit, offset=offset\n        )\n\n    def upload_documents(\n        self,\n        files: str | Image.Image | list[str | Image.Image],\n        filenames: str | list[str] = None,\n        *,\n        batch_size: int = 5,\n    ) -&gt; list[Document]:\n        \"\"\"Synchronously upload files to the collection in batches.\n\n        Args:\n            files (str | Image.Image | list[str | Image.Image]): The files to upload.\n                Can be a single instance or a list of a string containing the path to\n                a file or an `Image.Image` object.\n            filenames (str | list[str], optional): The filenames of the files to\n                upload. Defaults to None.\n            batch_size (int): The number of files to upload in each batch. Defaults\n                to 5.\n\n        Returns:\n            Documents: A list of created documents.\n\n        Raises:\n            TypeError: If an input file type is invalid.\n            ValueError: If the length of the filenames list does not match the length\n                of the files list.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; collection = lx.create_collection(collection_name='my_file_collection')\n            &gt;&gt;&gt; collection.upload_documents(\n            ...     files=[\n            ...         'lexy/sample_data/images/lexy-dalle.jpeg',\n            ...         'lexy/sample_data/images/lexy.png',\n            ...         'dais2023-233180.pdf',\n            ...         'gwdemo30.mp4',\n            ...         'kindle2.html',\n            ...     ]\n            ... )\n        \"\"\"\n        return self.client.document.upload_documents(\n            files=files,\n            filenames=filenames,\n            collection_id=self.collection_id,\n            batch_size=batch_size,\n        )\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.models.Collection.add_documents","title":"<code>add_documents(docs, *, batch_size=100)</code>","text":"<p>Synchronously add documents to the collection in batches.</p> <p>Parameters:</p> Name Type Description Default <code>docs</code> <code>Document | dict | list[Document | dict]</code> <p>The documents to add.</p> required <code>batch_size</code> <code>int</code> <p>The number of documents to add in each batch. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>Documents</code> <code>list[Document]</code> <p>A list of created documents.</p> Source code in <code>sdk-python/lexy_py/collection/models.py</code> <pre><code>def add_documents(\n    self, docs: Document | dict | list[Document | dict], *, batch_size: int = 100\n) -&gt; list[Document]:\n    \"\"\"Synchronously add documents to the collection in batches.\n\n    Args:\n        docs (Document | dict | list[Document | dict]): The documents to add.\n        batch_size (int): The number of documents to add in each batch. Defaults\n            to 100.\n\n    Returns:\n        Documents: A list of created documents.\n    \"\"\"\n    return self.client.document.add_documents(\n        docs, collection_id=self.collection_id, batch_size=batch_size\n    )\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.models.Collection.list_documents","title":"<code>list_documents(*, limit=100, offset=0)</code>","text":"<p>Synchronously get a list of documents in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of documents to return. Defaults to 100. Maximum allowed is 1000.</p> <code>100</code> <code>offset</code> <code>int</code> <p>The offset to start from. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Documents</code> <code>list[Document]</code> <p>A list of documents in the collection.</p> Source code in <code>sdk-python/lexy_py/collection/models.py</code> <pre><code>def list_documents(self, *, limit: int = 100, offset: int = 0) -&gt; list[Document]:\n    \"\"\"Synchronously get a list of documents in the collection.\n\n    Args:\n        limit (int): The maximum number of documents to return. Defaults to 100.\n            Maximum allowed is 1000.\n        offset (int): The offset to start from. Defaults to 0.\n\n    Returns:\n        Documents: A list of documents in the collection.\n    \"\"\"\n    return self.client.document.list_documents(\n        collection_id=self.collection_id, limit=limit, offset=offset\n    )\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.models.Collection.upload_documents","title":"<code>upload_documents(files, filenames=None, *, batch_size=5)</code>","text":"<p>Synchronously upload files to the collection in batches.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>str | Image | list[str | Image]</code> <p>The files to upload. Can be a single instance or a list of a string containing the path to a file or an <code>Image.Image</code> object.</p> required <code>filenames</code> <code>str | list[str]</code> <p>The filenames of the files to upload. Defaults to None.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of files to upload in each batch. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>Documents</code> <code>list[Document]</code> <p>A list of created documents.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If an input file type is invalid.</p> <code>ValueError</code> <p>If the length of the filenames list does not match the length of the files list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; collection = lx.create_collection(collection_name='my_file_collection')\n&gt;&gt;&gt; collection.upload_documents(\n...     files=[\n...         'lexy/sample_data/images/lexy-dalle.jpeg',\n...         'lexy/sample_data/images/lexy.png',\n...         'dais2023-233180.pdf',\n...         'gwdemo30.mp4',\n...         'kindle2.html',\n...     ]\n... )\n</code></pre> Source code in <code>sdk-python/lexy_py/collection/models.py</code> <pre><code>def upload_documents(\n    self,\n    files: str | Image.Image | list[str | Image.Image],\n    filenames: str | list[str] = None,\n    *,\n    batch_size: int = 5,\n) -&gt; list[Document]:\n    \"\"\"Synchronously upload files to the collection in batches.\n\n    Args:\n        files (str | Image.Image | list[str | Image.Image]): The files to upload.\n            Can be a single instance or a list of a string containing the path to\n            a file or an `Image.Image` object.\n        filenames (str | list[str], optional): The filenames of the files to\n            upload. Defaults to None.\n        batch_size (int): The number of files to upload in each batch. Defaults\n            to 5.\n\n    Returns:\n        Documents: A list of created documents.\n\n    Raises:\n        TypeError: If an input file type is invalid.\n        ValueError: If the length of the filenames list does not match the length\n            of the files list.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; collection = lx.create_collection(collection_name='my_file_collection')\n        &gt;&gt;&gt; collection.upload_documents(\n        ...     files=[\n        ...         'lexy/sample_data/images/lexy-dalle.jpeg',\n        ...         'lexy/sample_data/images/lexy.png',\n        ...         'dais2023-233180.pdf',\n        ...         'gwdemo30.mp4',\n        ...         'kindle2.html',\n        ...     ]\n        ... )\n    \"\"\"\n    return self.client.document.upload_documents(\n        files=files,\n        filenames=filenames,\n        collection_id=self.collection_id,\n        batch_size=batch_size,\n    )\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.models.CollectionModel","title":"<code>lexy_py.collection.models.CollectionModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Collection model</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection. Must be unique across collections.</p> required <code>description</code> <code>str | None</code> <code>None</code> <code>config</code> <code>dict[str, Any] | None</code> <code>{}</code> <code>created_at</code> <code>datetime | None</code> <code>None</code> <code>updated_at</code> <code>datetime | None</code> <code>None</code> <code>collection_id</code> <code>str | None</code> <code>None</code> Source code in <code>sdk-python/lexy_py/collection/models.py</code> <pre><code>class CollectionModel(BaseModel):\n    \"\"\"Collection model\"\"\"\n\n    collection_name: str = Field(\n        title=\"Collection Name\",\n        description=\"The name of the collection. Must be unique across collections.\",\n        min_length=1,\n        max_length=56,\n        pattern=\"^[a-z_][a-z0-9_]{0,55}$\",\n    )\n    description: Optional[str] = None\n    config: Optional[dict[str, Any]] = Field(default={})\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n    collection_id: Optional[str] = None\n\n    def __repr__(self):\n        return (\n            f\"&lt;Collection(\"\n            f\"'{self.collection_name}', \"\n            f\"id='{self.collection_id}', \"\n            f\"description='{self.description}')&gt;\"\n        )\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient","title":"<code>lexy_py.collection.client.CollectionClient</code>","text":"<p>This class is used to interact with the Lexy Collection API.</p> <p>Attributes:</p> Name Type Description <code>aclient</code> <code>AsyncClient</code> <p>Asynchronous API client.</p> <code>client</code> <code>Client</code> <p>Synchronous API client.</p> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>class CollectionClient:\n    \"\"\"\n    This class is used to interact with the Lexy Collection API.\n\n    Attributes:\n        aclient (httpx.AsyncClient): Asynchronous API client.\n        client (httpx.Client): Synchronous API client.\n    \"\"\"\n\n    def __init__(self, lexy_client: \"LexyClient\") -&gt; None:\n        self._lexy_client = lexy_client\n\n    @property\n    def aclient(self) -&gt; httpx.AsyncClient:\n        return self._lexy_client.aclient\n\n    @property\n    def client(self) -&gt; httpx.Client:\n        return self._lexy_client.client\n\n    def list_collections(self) -&gt; list[Collection]:\n        \"\"\"Synchronously get a list of all collections.\n\n        Returns:\n            list[Collection]: A list of all collections.\n        \"\"\"\n        r = self.client.get(\"/collections\")\n        handle_response(r)\n        return [\n            Collection(**collection, client=self._lexy_client)\n            for collection in r.json()\n        ]\n\n    async def alist_collections(self) -&gt; list[Collection]:\n        \"\"\"Asynchronously get a list of all collections.\n\n        Returns:\n            list[Collection]: A list of all collections.\n        \"\"\"\n        r = await self.aclient.get(\"/collections\")\n        handle_response(r)\n        return [\n            Collection(**collection, client=self._lexy_client)\n            for collection in r.json()\n        ]\n\n    def get_collection(\n        self, *, collection_name: str = None, collection_id: str = None\n    ) -&gt; Collection:\n        \"\"\"Synchronously get a collection by name or ID.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            collection_name (str): The name of the collection to get.\n            collection_id (str): The ID of the collection to get. If provided,\n                `collection_name` will be ignored.\n\n        Returns:\n            Collection: The collection.\n\n        Raises:\n            ValueError: If neither `collection_name` nor `collection_id` are provided.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; lx.get_collection(collection_id=\"70b8ce75\")\n            &lt;Collection('test_collection', id='70b8ce75', description='My Test Collection')&gt;\n\n            &gt;&gt;&gt; lx.get_collection(collection_name=\"test_collection\")\n            &lt;Collection('test_collection', id='70b8ce75', description='My Test Collection')&gt;\n        \"\"\"\n        if collection_id:\n            return self.get_collection_by_id(collection_id)\n        elif collection_name:\n            return self.get_collection_by_name(collection_name)\n        else:\n            raise ValueError(\n                \"Either collection_id or collection_name must be provided.\"\n            )\n\n    async def aget_collection(\n        self, *, collection_name: str = None, collection_id: str = None\n    ) -&gt; Collection:\n        \"\"\"Asynchronously get a collection by name or ID.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            collection_name (str): The name of the collection to get.\n            collection_id (str): The ID of the collection to get. If provided,\n                `collection_name` will be ignored.\n\n        Returns:\n            Collection: The collection.\n\n        Raises:\n            ValueError: If neither `collection_name` nor `collection_id` are provided.\n        \"\"\"\n        if collection_id:\n            return await self.aget_collection_by_id(collection_id)\n        elif collection_name:\n            return await self.aget_collection_by_name(collection_name)\n        else:\n            raise ValueError(\n                \"Either 'collection_name' or 'collection_id' must be provided.\"\n            )\n\n    def get_collection_by_id(self, collection_id: str) -&gt; Collection:\n        \"\"\"Synchronously get a collection by ID.\n\n        Args:\n            collection_id (str): The ID of the collection to get.\n\n        Returns:\n            Collection: The collection.\n        \"\"\"\n        r = self.client.get(f\"/collections/{collection_id}\")\n        handle_response(r)\n        return Collection(**r.json(), client=self._lexy_client)\n\n    async def aget_collection_by_id(self, collection_id: str) -&gt; Collection:\n        \"\"\"Asynchronously get a collection by ID.\n\n        Args:\n            collection_id (str): The ID of the collection to get.\n\n        Returns:\n            Collection: The collection.\n        \"\"\"\n        r = await self.aclient.get(f\"/collections/{collection_id}\")\n        handle_response(r)\n        return Collection(**r.json(), client=self._lexy_client)\n\n    def get_collection_by_name(self, collection_name: str) -&gt; Collection:\n        \"\"\"Synchronously get a collection by name.\n\n        Args:\n            collection_name (str): The name of the collection to get.\n\n        Returns:\n            Collection: The collection.\n        \"\"\"\n        r = self.client.get(\n            url=\"/collections\", params={\"collection_name\": collection_name}\n        )\n        handle_response(r)\n        return Collection(**r.json(), client=self._lexy_client)\n\n    async def aget_collection_by_name(self, collection_name: str) -&gt; Collection:\n        \"\"\"Asynchronously get a collection by name.\n\n        Args:\n            collection_name (str): The name of the collection to get.\n\n        Returns:\n            Collection: The collection.\n        \"\"\"\n        r = await self.aclient.get(\n            url=\"/collections\", params={\"collection_name\": collection_name}\n        )\n        handle_response(r)\n        return Collection(**r.json(), client=self._lexy_client)\n\n    def create_collection(\n        self,\n        collection_name: str,\n        *,\n        description: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; Collection:\n        \"\"\"Synchronously create a new collection.\n\n        Args:\n            collection_name (str): The name of the collection to create. Collection\n                names must be unique.\n            description (str, optional): The description of the collection. Defaults to\n                None.\n            config (dict, optional): The config of the collection. Defaults to None.\n\n        Returns:\n            Collection: The created collection.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; lx.create_collection(\"test_collection\", description=\"My Test Collection\")\n            &lt;Collection('test_collection', id='70b8ce75', description='My Test Collection')&gt;\n\n            &gt;&gt;&gt; lx.create_collection(collection_name=\"no_files\",\n            ...                      description=\"Collection without files\",\n            ...                      config={\"store_files\": False})\n            &lt;Collection('no_files', id='925d40ac', description='Collection without files')&gt;\n        \"\"\"\n        collection = Collection(\n            collection_name=collection_name, description=description, config=config\n        )\n        r = self.client.post(\n            url=\"/collections\", json=collection.model_dump(exclude_none=True)\n        )\n        handle_response(r)\n        return Collection(**r.json(), client=self._lexy_client)\n\n    async def acreate_collection(\n        self,\n        collection_name: str,\n        *,\n        description: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; Collection:\n        \"\"\"Asynchronously create a new collection.\n\n        Args:\n            collection_name (str): The name of the collection to create. Collection\n                names must be unique.\n            description (str, optional): The description of the collection. Defaults to\n                None.\n            config (dict, optional): The config of the collection. Defaults to None.\n\n        Returns:\n            Collection: The created collection.\n        \"\"\"\n        collection = Collection(\n            collection_name=collection_name, description=description, config=config\n        )\n        r = await self.aclient.post(\n            url=\"/collections\", json=collection.model_dump(exclude_none=True)\n        )\n        handle_response(r)\n        return Collection(**r.json(), client=self._lexy_client)\n\n    def update_collection(\n        self,\n        *,\n        collection_id: str,\n        collection_name: Optional[str] = None,\n        description: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; Collection:\n        \"\"\"Synchronously update a collection.\n\n        Args:\n            collection_id (str): The ID of the collection to update.\n            collection_name (str, optional): The updated name of the collection.\n                Defaults to None.\n            description (str, optional): The updated description of the collection.\n                Defaults to None.\n            config: (dict, optional): The updated config of the collection. Defaults\n                to None.\n\n        Returns:\n            Collection: The updated collection.\n        \"\"\"\n        collection = CollectionUpdate(\n            collection_name=collection_name, description=description, config=config\n        )\n        r = self.client.patch(\n            url=f\"/collections/{collection_id}\",\n            json=collection.model_dump(exclude_none=True),\n        )\n        handle_response(r)\n        return Collection(**r.json(), client=self._lexy_client)\n\n    async def aupdate_collection(\n        self,\n        *,\n        collection_id: str,\n        collection_name: Optional[str] = None,\n        description: Optional[str] = None,\n        config: Optional[dict] = None,\n    ) -&gt; Collection:\n        \"\"\"Asynchronously update a collection.\n\n        Args:\n            collection_id (str): The ID of the collection to update.\n            collection_name (str, optional): The updated name of the collection.\n                Defaults to None.\n            description (str, optional): The updated description of the collection.\n                Defaults to None.\n            config: (dict, optional): The updated config of the collection. Defaults\n                to None.\n\n        Returns:\n            Collection: The updated collection.\n        \"\"\"\n        collection = CollectionUpdate(\n            collection_name=collection_name, description=description, config=config\n        )\n        r = await self.aclient.patch(\n            url=f\"/collections/{collection_id}\",\n            json=collection.model_dump(exclude_none=True),\n        )\n        handle_response(r)\n        return Collection(**r.json(), client=self._lexy_client)\n\n    def delete_collection(\n        self,\n        *,\n        collection_name: str = None,\n        collection_id: str = None,\n        delete_documents: bool = False,\n    ) -&gt; dict:\n        \"\"\"Synchronously delete a collection by name or ID.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            collection_name (str): The name of the collection to delete.\n            collection_id (str): The ID of the collection to delete. If provided,\n                `collection_name` will be ignored.\n            delete_documents (bool, optional): Whether to delete the documents in the\n                collection. Defaults to False.\n\n        Raises:\n            ValueError: If neither `collection_name` nor `collection_id` are provided.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; lx.delete_collection(collection_name=\"test_collection\", delete_documents=True)\n            {\"msg\": \"Collection deleted\", \"collection_id\": \"70b8ce75\", \"documents_deleted\": 3}\n        \"\"\"\n        if collection_id:\n            r = self.client.delete(\n                url=f\"/collections/{collection_id}\",\n                params={\"delete_documents\": delete_documents},\n            )\n        elif collection_name:\n            r = self.client.delete(\n                url=\"/collections\",\n                params={\n                    \"collection_name\": collection_name,\n                    \"delete_documents\": delete_documents,\n                },\n            )\n        else:\n            raise ValueError(\n                \"Either 'collection_name' or 'collection_id' must be provided.\"\n            )\n        handle_response(r)\n        return r.json()\n\n    async def adelete_collection(\n        self,\n        *,\n        collection_name: str = None,\n        collection_id: str = None,\n        delete_documents: bool = False,\n    ) -&gt; dict:\n        \"\"\"Asynchronously delete a collection by name or ID.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            collection_name (str): The name of the collection to delete.\n            collection_id (str): The ID of the collection to delete. If provided,\n                `collection_name` will be ignored.\n            delete_documents (bool, optional): Whether to delete the documents in the\n                collection. Defaults to False.\n\n        Raises:\n            ValueError: If neither `collection_name` nor `collection_id` are provided.\n        \"\"\"\n        if collection_id:\n            r = await self.aclient.delete(\n                url=f\"/collections/{collection_id}\",\n                params={\"delete_documents\": delete_documents},\n            )\n        elif collection_name:\n            r = await self.aclient.delete(\n                url=\"/collections\",\n                params={\n                    \"collection_name\": collection_name,\n                    \"delete_documents\": delete_documents,\n                },\n            )\n        else:\n            raise ValueError(\n                \"Either 'collection_name' or 'collection_id' must be provided.\"\n            )\n        handle_response(r)\n        return r.json()\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.create_collection","title":"<code>create_collection(collection_name, *, description=None, config=None)</code>","text":"<p>Synchronously create a new collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to create. Collection names must be unique.</p> required <code>description</code> <code>str</code> <p>The description of the collection. Defaults to None.</p> <code>None</code> <code>config</code> <code>dict</code> <p>The config of the collection. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Collection</code> <code>Collection</code> <p>The created collection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; lx.create_collection(\"test_collection\", description=\"My Test Collection\")\n&lt;Collection('test_collection', id='70b8ce75', description='My Test Collection')&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; lx.create_collection(collection_name=\"no_files\",\n...                      description=\"Collection without files\",\n...                      config={\"store_files\": False})\n&lt;Collection('no_files', id='925d40ac', description='Collection without files')&gt;\n</code></pre> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>def create_collection(\n    self,\n    collection_name: str,\n    *,\n    description: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; Collection:\n    \"\"\"Synchronously create a new collection.\n\n    Args:\n        collection_name (str): The name of the collection to create. Collection\n            names must be unique.\n        description (str, optional): The description of the collection. Defaults to\n            None.\n        config (dict, optional): The config of the collection. Defaults to None.\n\n    Returns:\n        Collection: The created collection.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; lx.create_collection(\"test_collection\", description=\"My Test Collection\")\n        &lt;Collection('test_collection', id='70b8ce75', description='My Test Collection')&gt;\n\n        &gt;&gt;&gt; lx.create_collection(collection_name=\"no_files\",\n        ...                      description=\"Collection without files\",\n        ...                      config={\"store_files\": False})\n        &lt;Collection('no_files', id='925d40ac', description='Collection without files')&gt;\n    \"\"\"\n    collection = Collection(\n        collection_name=collection_name, description=description, config=config\n    )\n    r = self.client.post(\n        url=\"/collections\", json=collection.model_dump(exclude_none=True)\n    )\n    handle_response(r)\n    return Collection(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.delete_collection","title":"<code>delete_collection(*, collection_name=None, collection_id=None, delete_documents=False)</code>","text":"<p>Synchronously delete a collection by name or ID.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to delete.</p> <code>None</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to delete. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <code>delete_documents</code> <code>bool</code> <p>Whether to delete the documents in the collection. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>collection_name</code> nor <code>collection_id</code> are provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; lx.delete_collection(collection_name=\"test_collection\", delete_documents=True)\n{\"msg\": \"Collection deleted\", \"collection_id\": \"70b8ce75\", \"documents_deleted\": 3}\n</code></pre> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>def delete_collection(\n    self,\n    *,\n    collection_name: str = None,\n    collection_id: str = None,\n    delete_documents: bool = False,\n) -&gt; dict:\n    \"\"\"Synchronously delete a collection by name or ID.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        collection_name (str): The name of the collection to delete.\n        collection_id (str): The ID of the collection to delete. If provided,\n            `collection_name` will be ignored.\n        delete_documents (bool, optional): Whether to delete the documents in the\n            collection. Defaults to False.\n\n    Raises:\n        ValueError: If neither `collection_name` nor `collection_id` are provided.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; lx.delete_collection(collection_name=\"test_collection\", delete_documents=True)\n        {\"msg\": \"Collection deleted\", \"collection_id\": \"70b8ce75\", \"documents_deleted\": 3}\n    \"\"\"\n    if collection_id:\n        r = self.client.delete(\n            url=f\"/collections/{collection_id}\",\n            params={\"delete_documents\": delete_documents},\n        )\n    elif collection_name:\n        r = self.client.delete(\n            url=\"/collections\",\n            params={\n                \"collection_name\": collection_name,\n                \"delete_documents\": delete_documents,\n            },\n        )\n    else:\n        raise ValueError(\n            \"Either 'collection_name' or 'collection_id' must be provided.\"\n        )\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.get_collection","title":"<code>get_collection(*, collection_name=None, collection_id=None)</code>","text":"<p>Synchronously get a collection by name or ID.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to get.</p> <code>None</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to get. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Collection</code> <code>Collection</code> <p>The collection.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>collection_name</code> nor <code>collection_id</code> are provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; lx.get_collection(collection_id=\"70b8ce75\")\n&lt;Collection('test_collection', id='70b8ce75', description='My Test Collection')&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; lx.get_collection(collection_name=\"test_collection\")\n&lt;Collection('test_collection', id='70b8ce75', description='My Test Collection')&gt;\n</code></pre> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>def get_collection(\n    self, *, collection_name: str = None, collection_id: str = None\n) -&gt; Collection:\n    \"\"\"Synchronously get a collection by name or ID.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        collection_name (str): The name of the collection to get.\n        collection_id (str): The ID of the collection to get. If provided,\n            `collection_name` will be ignored.\n\n    Returns:\n        Collection: The collection.\n\n    Raises:\n        ValueError: If neither `collection_name` nor `collection_id` are provided.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; lx.get_collection(collection_id=\"70b8ce75\")\n        &lt;Collection('test_collection', id='70b8ce75', description='My Test Collection')&gt;\n\n        &gt;&gt;&gt; lx.get_collection(collection_name=\"test_collection\")\n        &lt;Collection('test_collection', id='70b8ce75', description='My Test Collection')&gt;\n    \"\"\"\n    if collection_id:\n        return self.get_collection_by_id(collection_id)\n    elif collection_name:\n        return self.get_collection_by_name(collection_name)\n    else:\n        raise ValueError(\n            \"Either collection_id or collection_name must be provided.\"\n        )\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.list_collections","title":"<code>list_collections()</code>","text":"<p>Synchronously get a list of all collections.</p> <p>Returns:</p> Type Description <code>list[Collection]</code> <p>list[Collection]: A list of all collections.</p> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>def list_collections(self) -&gt; list[Collection]:\n    \"\"\"Synchronously get a list of all collections.\n\n    Returns:\n        list[Collection]: A list of all collections.\n    \"\"\"\n    r = self.client.get(\"/collections\")\n    handle_response(r)\n    return [\n        Collection(**collection, client=self._lexy_client)\n        for collection in r.json()\n    ]\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.update_collection","title":"<code>update_collection(*, collection_id, collection_name=None, description=None, config=None)</code>","text":"<p>Synchronously update a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>The ID of the collection to update.</p> required <code>collection_name</code> <code>str</code> <p>The updated name of the collection. Defaults to None.</p> <code>None</code> <code>description</code> <code>str</code> <p>The updated description of the collection. Defaults to None.</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>(dict, optional): The updated config of the collection. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Collection</code> <code>Collection</code> <p>The updated collection.</p> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>def update_collection(\n    self,\n    *,\n    collection_id: str,\n    collection_name: Optional[str] = None,\n    description: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; Collection:\n    \"\"\"Synchronously update a collection.\n\n    Args:\n        collection_id (str): The ID of the collection to update.\n        collection_name (str, optional): The updated name of the collection.\n            Defaults to None.\n        description (str, optional): The updated description of the collection.\n            Defaults to None.\n        config: (dict, optional): The updated config of the collection. Defaults\n            to None.\n\n    Returns:\n        Collection: The updated collection.\n    \"\"\"\n    collection = CollectionUpdate(\n        collection_name=collection_name, description=description, config=config\n    )\n    r = self.client.patch(\n        url=f\"/collections/{collection_id}\",\n        json=collection.model_dump(exclude_none=True),\n    )\n    handle_response(r)\n    return Collection(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.acreate_collection","title":"<code>acreate_collection(collection_name, *, description=None, config=None)</code>  <code>async</code>","text":"<p>Asynchronously create a new collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to create. Collection names must be unique.</p> required <code>description</code> <code>str</code> <p>The description of the collection. Defaults to None.</p> <code>None</code> <code>config</code> <code>dict</code> <p>The config of the collection. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Collection</code> <code>Collection</code> <p>The created collection.</p> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>async def acreate_collection(\n    self,\n    collection_name: str,\n    *,\n    description: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; Collection:\n    \"\"\"Asynchronously create a new collection.\n\n    Args:\n        collection_name (str): The name of the collection to create. Collection\n            names must be unique.\n        description (str, optional): The description of the collection. Defaults to\n            None.\n        config (dict, optional): The config of the collection. Defaults to None.\n\n    Returns:\n        Collection: The created collection.\n    \"\"\"\n    collection = Collection(\n        collection_name=collection_name, description=description, config=config\n    )\n    r = await self.aclient.post(\n        url=\"/collections\", json=collection.model_dump(exclude_none=True)\n    )\n    handle_response(r)\n    return Collection(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.adelete_collection","title":"<code>adelete_collection(*, collection_name=None, collection_id=None, delete_documents=False)</code>  <code>async</code>","text":"<p>Asynchronously delete a collection by name or ID.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to delete.</p> <code>None</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to delete. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <code>delete_documents</code> <code>bool</code> <p>Whether to delete the documents in the collection. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>collection_name</code> nor <code>collection_id</code> are provided.</p> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>async def adelete_collection(\n    self,\n    *,\n    collection_name: str = None,\n    collection_id: str = None,\n    delete_documents: bool = False,\n) -&gt; dict:\n    \"\"\"Asynchronously delete a collection by name or ID.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        collection_name (str): The name of the collection to delete.\n        collection_id (str): The ID of the collection to delete. If provided,\n            `collection_name` will be ignored.\n        delete_documents (bool, optional): Whether to delete the documents in the\n            collection. Defaults to False.\n\n    Raises:\n        ValueError: If neither `collection_name` nor `collection_id` are provided.\n    \"\"\"\n    if collection_id:\n        r = await self.aclient.delete(\n            url=f\"/collections/{collection_id}\",\n            params={\"delete_documents\": delete_documents},\n        )\n    elif collection_name:\n        r = await self.aclient.delete(\n            url=\"/collections\",\n            params={\n                \"collection_name\": collection_name,\n                \"delete_documents\": delete_documents,\n            },\n        )\n    else:\n        raise ValueError(\n            \"Either 'collection_name' or 'collection_id' must be provided.\"\n        )\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.aget_collection","title":"<code>aget_collection(*, collection_name=None, collection_id=None)</code>  <code>async</code>","text":"<p>Asynchronously get a collection by name or ID.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to get.</p> <code>None</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to get. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Collection</code> <code>Collection</code> <p>The collection.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>collection_name</code> nor <code>collection_id</code> are provided.</p> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>async def aget_collection(\n    self, *, collection_name: str = None, collection_id: str = None\n) -&gt; Collection:\n    \"\"\"Asynchronously get a collection by name or ID.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        collection_name (str): The name of the collection to get.\n        collection_id (str): The ID of the collection to get. If provided,\n            `collection_name` will be ignored.\n\n    Returns:\n        Collection: The collection.\n\n    Raises:\n        ValueError: If neither `collection_name` nor `collection_id` are provided.\n    \"\"\"\n    if collection_id:\n        return await self.aget_collection_by_id(collection_id)\n    elif collection_name:\n        return await self.aget_collection_by_name(collection_name)\n    else:\n        raise ValueError(\n            \"Either 'collection_name' or 'collection_id' must be provided.\"\n        )\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.alist_collections","title":"<code>alist_collections()</code>  <code>async</code>","text":"<p>Asynchronously get a list of all collections.</p> <p>Returns:</p> Type Description <code>list[Collection]</code> <p>list[Collection]: A list of all collections.</p> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>async def alist_collections(self) -&gt; list[Collection]:\n    \"\"\"Asynchronously get a list of all collections.\n\n    Returns:\n        list[Collection]: A list of all collections.\n    \"\"\"\n    r = await self.aclient.get(\"/collections\")\n    handle_response(r)\n    return [\n        Collection(**collection, client=self._lexy_client)\n        for collection in r.json()\n    ]\n</code></pre>"},{"location":"reference/lexy_py/collection/#lexy_py.collection.client.CollectionClient.aupdate_collection","title":"<code>aupdate_collection(*, collection_id, collection_name=None, description=None, config=None)</code>  <code>async</code>","text":"<p>Asynchronously update a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>str</code> <p>The ID of the collection to update.</p> required <code>collection_name</code> <code>str</code> <p>The updated name of the collection. Defaults to None.</p> <code>None</code> <code>description</code> <code>str</code> <p>The updated description of the collection. Defaults to None.</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>(dict, optional): The updated config of the collection. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Collection</code> <code>Collection</code> <p>The updated collection.</p> Source code in <code>sdk-python/lexy_py/collection/client.py</code> <pre><code>async def aupdate_collection(\n    self,\n    *,\n    collection_id: str,\n    collection_name: Optional[str] = None,\n    description: Optional[str] = None,\n    config: Optional[dict] = None,\n) -&gt; Collection:\n    \"\"\"Asynchronously update a collection.\n\n    Args:\n        collection_id (str): The ID of the collection to update.\n        collection_name (str, optional): The updated name of the collection.\n            Defaults to None.\n        description (str, optional): The updated description of the collection.\n            Defaults to None.\n        config: (dict, optional): The updated config of the collection. Defaults\n            to None.\n\n    Returns:\n        Collection: The updated collection.\n    \"\"\"\n    collection = CollectionUpdate(\n        collection_name=collection_name, description=description, config=config\n    )\n    r = await self.aclient.patch(\n        url=f\"/collections/{collection_id}\",\n        json=collection.model_dump(exclude_none=True),\n    )\n    handle_response(r)\n    return Collection(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/document/","title":"Documentation for <code>Document</code>","text":""},{"location":"reference/lexy_py/document/#lexy_py.document.models.Document","title":"<code>lexy_py.document.models.Document</code>","text":"<p>             Bases: <code>DocumentModel</code></p> <p>Document model</p> Source code in <code>sdk-python/lexy_py/document/models.py</code> <pre><code>class Document(DocumentModel):\n    __doc__ = DocumentModel.__doc__\n    _client: Optional[\"LexyClient\"] = PrivateAttr(default=None)\n    _image: Optional[\"Image\"] = PrivateAttr(default=None)\n    _urls: Optional[dict] = PrivateAttr(default=None)\n\n    def __init__(self, content: str, **data: Any):\n        super().__init__(content=content, **data)\n        self._client = data.pop(\"client\", None)\n\n    @property\n    def client(self) -&gt; \"LexyClient\":\n        if not self._client:\n            raise ValueError(\"API client has not been set.\")\n        return self._client\n\n    @property\n    def image(self) -&gt; Image:\n        if not self._image:\n            self._image = self.meta.get(\"image\", {}).get(\"im\")\n        if not self._image:\n            base64_str = self.meta.get(\"image\", {}).get(\"base64\")\n            if base64_str:\n                self._image = self.image_from_base64_str(base64_str)\n        if not self._image:\n            if self.object_url:\n                self._image = self.image_from_url(self.object_url)\n        return self._image\n\n    @property\n    def object_url(self) -&gt; str | None:\n        if self._urls is None:\n            self._refresh_urls()\n        url = self._urls.get(\"object\", None)\n        # check if url is expired and refresh if needed\n        storage_service = self.meta.get(\"storage_service\")\n        if url and presigned_url_is_expired(url, storage_service=storage_service):\n            self._refresh_urls()\n            url = self._urls.get(\"object\", None)\n        return url\n\n    def get_thumbnail_url(\n        self, size: tuple[int, int] = (200, 200), refresh: bool = False\n    ) -&gt; str | None:\n        if self._urls is None or refresh:\n            self._refresh_urls()\n        url = self._urls.get(\"thumbnails\", {}).get(f\"{size[0]}x{size[1]}\")\n        # if that size doesn't exist, get any size\n        if not url:\n            url = next(iter(self._urls.get(\"thumbnails\", {}).values()), None)\n        # check if url is expired and refresh if needed\n        storage_service = (\n            self.meta.get(\"image\", {})\n            .get(\"thumbnails\", {})\n            .get(f\"{size[0]}x{size[1]}\", {})\n            .get(\"storage_service\")\n        )\n        if url and presigned_url_is_expired(url, storage_service=storage_service):\n            return self.get_thumbnail_url(size, refresh=True)\n        return url\n\n    thumbnail_url = property(get_thumbnail_url)\n\n    def _refresh_urls(self):\n        self._urls = self.client.document.get_document_urls(self.document_id)\n\n    # TODO: move to future ImageDocument class\n    def image_from_url(self, url: str) -&gt; Image:\n        if self._client:\n            r = self.client.get(url)\n        else:\n            import httpx\n\n            r = httpx.get(url)\n        return Image.open(BytesIO(r.content))\n\n    # TODO: move to future ImageDocument class\n    @staticmethod\n    def image_from_base64_str(base64_str: str) -&gt; Image:\n        img_bytes = base64.b64decode(base64_str)\n        return Image.open(BytesIO(img_bytes))\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.models.DocumentModel","title":"<code>lexy_py.document.models.DocumentModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Document model</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str | None</code> <code>None</code> <code>content</code> <code>str</code> required <code>meta</code> <code>dict[Any, Any] | None</code> <code>{}</code> <code>created_at</code> <code>datetime | None</code> <code>None</code> <code>updated_at</code> <code>datetime | None</code> <code>None</code> <code>collection_id</code> <code>str | None</code> <code>None</code> Source code in <code>sdk-python/lexy_py/document/models.py</code> <pre><code>class DocumentModel(BaseModel):\n    \"\"\"Document model\"\"\"\n\n    document_id: Optional[str] = None\n    content: str = Field(...)\n    meta: Optional[dict[Any, Any]] = Field(default={})\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n    collection_id: Optional[str] = None\n\n    def __repr__(self):\n        return f'&lt;Document(\"{textwrap.shorten(self.content, 100, placeholder=\"...\")}\")&gt;'\n\n    def __init__(self, content: str, **data: Any):\n        super().__init__(content=content, **data)\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient","title":"<code>lexy_py.document.client.DocumentClient</code>","text":"<p>This class is used to interact with the Lexy Document API.</p> <p>Attributes:</p> Name Type Description <code>aclient</code> <code>AsyncClient</code> <p>Asynchronous API client.</p> <code>client</code> <code>Client</code> <p>Synchronous API client.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>class DocumentClient:\n    \"\"\"\n    This class is used to interact with the Lexy Document API.\n\n    Attributes:\n        aclient (httpx.AsyncClient): Asynchronous API client.\n        client (httpx.Client): Synchronous API client.\n    \"\"\"\n\n    def __init__(self, lexy_client: \"LexyClient\") -&gt; None:\n        self._lexy_client = lexy_client\n\n    @property\n    def aclient(self) -&gt; httpx.AsyncClient:\n        return self._lexy_client.aclient\n\n    @property\n    def client(self) -&gt; httpx.Client:\n        return self._lexy_client.client\n\n    def list_documents(\n        self,\n        *,\n        collection_name: str | None = \"default\",\n        collection_id: str = None,\n        limit: int = 100,\n        offset: int = 0,\n    ) -&gt; list[Document]:\n        \"\"\"Synchronously get a list of documents in a collection.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            collection_name (str): The name of the collection to get documents from.\n                Defaults to \"default\".\n            collection_id (str): The ID of the collection to get documents from.\n                Defaults to None. If provided, `collection_name` will be ignored.\n            limit (int): The maximum number of documents to return. Defaults to 100.\n                Maximum allowed is 1000.\n            offset (int): The offset to start from. Defaults to 0.\n\n        Returns:\n            Documents: A list of documents in a collection.\n        \"\"\"\n        if collection_id is not None:\n            r = self.client.get(\n                f\"/collections/{collection_id}/documents\",\n                params={\"limit\": limit, \"offset\": offset},\n            )\n        else:\n            r = self.client.get(\n                \"/documents\",\n                params={\n                    \"collection_name\": collection_name,\n                    \"limit\": limit,\n                    \"offset\": offset,\n                },\n            )\n        handle_response(r)\n        return [Document(**document, client=self._lexy_client) for document in r.json()]\n\n    async def alist_documents(\n        self,\n        *,\n        collection_name: str = \"default\",\n        collection_id: str = None,\n        limit: int = 100,\n        offset: int = 0,\n    ) -&gt; list[Document]:\n        \"\"\"Asynchronously get a list of documents in a collection.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            collection_name (str): The name of the collection to get documents from.\n                Defaults to \"default\".\n            collection_id (str): The ID of the collection to get documents from.\n                Defaults to None. If provided, `collection_name` will be ignored.\n            limit (int): The maximum number of documents to return. Defaults to 100.\n                Maximum allowed is 1000.\n            offset (int): The offset to start from. Defaults to 0.\n\n        Returns:\n            Documents: A list of documents in a collection.\n        \"\"\"\n        if collection_id is not None:\n            r = await self.aclient.get(\n                f\"/collections/{collection_id}/documents\",\n                params={\"limit\": limit, \"offset\": offset},\n            )\n        else:\n            r = await self.aclient.get(\n                \"/documents\",\n                params={\n                    \"collection_name\": collection_name,\n                    \"limit\": limit,\n                    \"offset\": offset,\n                },\n            )\n        handle_response(r)\n        return [Document(**document, client=self._lexy_client) for document in r.json()]\n\n    def add_documents(\n        self,\n        docs: Document | dict | list[Document | dict],\n        *,\n        collection_name: str = \"default\",\n        collection_id: str = None,\n        batch_size: int = 100,\n    ) -&gt; list[Document]:\n        \"\"\"Synchronously add documents to a collection in batches.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            docs (Document | dict | list[Document | dict]): The documents to add.\n            collection_name (str): The name of the collection to add the documents to.\n                Defaults to \"default\".\n            collection_id (str): The ID of the collection to add the documents to.\n                Defaults to None. If provided, `collection_name` will be ignored.\n            batch_size (int): The number of documents to add in each batch. Defaults\n                to 100.\n\n        Returns:\n            Documents: A list of created documents.\n\n        Examples:\n            Add documents to the default collection:\n\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; docs_added = lx.add_documents(docs=[\n            ...     {\"content\": \"Default document 1\"},\n            ...     {\"content\": \"Default document 2\"}\n            ... ])\n\n            Add documents to a specific collection by name:\n\n            &gt;&gt;&gt; my_new_collection = lx.create_collection(\"my_new_collection\")\n            &gt;&gt;&gt; docs_added = lx.add_documents(docs=[\n            ...     {\"content\": \"My first document\"},\n            ...     {\"content\": \"My second document\"}\n            ... ], collection_name=\"my_new_collection\")\n\n            Add documents to a specific collection by ID:\n\n            &gt;&gt;&gt; docs_added = lx.add_documents(docs=[\n            ...     {\"content\": \"My third document\"},\n            ...     {\"content\": \"My fourth document\"}\n            ... ], collection_id=my_new_collection.collection_id)\n\n        \"\"\"\n        created_docs = []\n        processed_docs = self._process_docs(docs)\n\n        for i in range(0, len(processed_docs), batch_size):\n            batch_docs = processed_docs[i : i + batch_size]\n\n            if collection_id is not None:\n                r = self.client.post(\n                    f\"/collections/{collection_id}/documents\", json=batch_docs\n                )\n            else:\n                r = self.client.post(\n                    \"/documents\",\n                    json=batch_docs,\n                    params={\"collection_name\": collection_name},\n                )\n\n            handle_response(r)\n            created_docs.extend(\n                [\n                    Document(**document[\"document\"], client=self._lexy_client)\n                    for document in r.json()\n                ]\n            )\n        return created_docs\n\n    async def aadd_documents(\n        self,\n        docs: Document | dict | list[Document | dict],\n        *,\n        collection_name: str = \"default\",\n        collection_id: str = None,\n        batch_size: int = 100,\n    ) -&gt; list[Document]:\n        \"\"\"Asynchronously add documents to a collection in batches.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            docs (Document | dict | list[Document | dict]): The documents to add.\n            collection_name (str): The name of the collection to add the documents to.\n                Defaults to \"default\".\n            collection_id (str): The ID of the collection to add the documents to.\n                Defaults to None. If provided, `collection_name` will be ignored.\n            batch_size (int): The number of documents to add in each batch. Defaults\n                to 100.\n\n        Returns:\n            Documents: A list of created documents.\n        \"\"\"\n        created_docs = []\n        processed_docs = self._process_docs(docs)\n\n        for i in range(0, len(processed_docs), batch_size):\n            batch_docs = processed_docs[i : i + batch_size]\n\n            if collection_id is not None:\n                r = await self.aclient.post(\n                    f\"/collections/{collection_id}/documents\", json=batch_docs\n                )\n            else:\n                r = await self.aclient.post(\n                    \"/documents\",\n                    json=batch_docs,\n                    params={\"collection_name\": collection_name},\n                )\n\n            handle_response(r)\n            created_docs.extend(\n                [\n                    Document(**document[\"document\"], client=self._lexy_client)\n                    for document in r.json()\n                ]\n            )\n        return created_docs\n\n    def add_document(\n        self,\n        doc: Document | dict,\n        *,\n        collection_name: str = \"default\",\n        collection_id: str = None,\n    ) -&gt; Document:\n        \"\"\"Synchronously add a document to a collection.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            doc (Document | dict): The document to add.\n            collection_name (str): The name of the collection to add the document to.\n                Defaults to \"default\".\n            collection_id (str): The ID of the collection to add the document to. If\n                provided, `collection_name` will be ignored.\n\n        Returns:\n            Document: The created document.\n        \"\"\"\n        processed_docs = self._process_docs(doc)\n\n        if collection_id is not None:\n            r = self.client.post(\n                f\"/collections/{collection_id}/documents\", json=processed_docs\n            )\n        else:\n            r = self.client.post(\n                \"/documents\",\n                json=processed_docs,\n                params={\"collection_name\": collection_name},\n            )\n\n        handle_response(r)\n        return Document(**r.json()[0][\"document\"], client=self._lexy_client)\n\n    async def aadd_document(\n        self,\n        doc: Document | dict,\n        *,\n        collection_name: str = \"default\",\n        collection_id: str = None,\n    ) -&gt; Document:\n        \"\"\"Asynchronously add a document to a collection.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            doc (Document | dict): The document to add.\n            collection_name (str): The name of the collection to add the document to.\n                Defaults to \"default\".\n            collection_id (str): The ID of the collection to add the document to. If\n                provided, `collection_name` will be ignored.\n\n        Returns:\n            Document: The created document.\n        \"\"\"\n        processed_docs = self._process_docs(doc)\n\n        if collection_id is not None:\n            r = await self.aclient.post(\n                f\"/collections/{collection_id}/documents\", json=processed_docs\n            )\n        else:\n            r = await self.aclient.post(\n                \"/documents\",\n                json=processed_docs,\n                params={\"collection_name\": collection_name},\n            )\n\n        handle_response(r)\n        return Document(**r.json()[0][\"document\"], client=self._lexy_client)\n\n    def get_document(self, document_id: str) -&gt; Document:\n        \"\"\"Synchronously get a document.\n\n        Args:\n            document_id (str): The ID of the document to get.\n\n        Returns:\n            Document: The document.\n        \"\"\"\n        r = self.client.get(f\"/documents/{document_id}\")\n        handle_response(r)\n        return Document(**r.json(), client=self._lexy_client)\n\n    async def aget_document(self, document_id: str) -&gt; Document:\n        \"\"\"Asynchronously get a document.\n\n        Args:\n            document_id (str): The ID of the document to get.\n\n        Returns:\n            Document: The document.\n        \"\"\"\n        r = await self.aclient.get(f\"/documents/{document_id}\")\n        handle_response(r)\n        return Document(**r.json(), client=self._lexy_client)\n\n    def update_document(\n        self,\n        document_id: str,\n        *,\n        content: Optional[str] = None,\n        meta: Optional[dict] = None,\n    ) -&gt; Document:\n        \"\"\"Synchronously update a document.\n\n        Args:\n            document_id (str): The ID of the document to update.\n            content (str, optional): The new content of the document.\n            meta (dict, optional): The new metadata for the document.\n\n        Returns:\n            Document: The updated document.\n        \"\"\"\n        document = DocumentUpdate(content=content, meta=meta)\n        r = self.client.patch(\n            f\"/documents/{document_id}\", json=document.model_dump(exclude_none=True)\n        )\n        handle_response(r)\n        return Document(**r.json()[\"document\"], client=self._lexy_client)\n\n    async def aupdate_document(\n        self,\n        document_id: str,\n        *,\n        content: Optional[str] = None,\n        meta: Optional[dict] = None,\n    ) -&gt; Document:\n        \"\"\"Asynchronously update a document.\n\n        Args:\n            document_id (str): The ID of the document to update.\n            content (str, optional): The new content of the document.\n            meta (dict, optional): The new metadata for the document.\n\n        Returns:\n            Document: The updated document.\n        \"\"\"\n        document = DocumentUpdate(content=content, meta=meta)\n        r = await self.aclient.patch(\n            f\"/documents/{document_id}\", json=document.model_dump(exclude_none=True)\n        )\n        handle_response(r)\n        return Document(**r.json()[\"document\"], client=self._lexy_client)\n\n    def delete_document(self, document_id: str) -&gt; dict:\n        \"\"\"Synchronously delete a document.\n\n        Args:\n            document_id (str): The ID of the document to delete.\n        \"\"\"\n        r = self.client.delete(f\"/documents/{document_id}\")\n        handle_response(r)\n        return r.json()\n\n    async def adelete_document(self, document_id: str) -&gt; dict:\n        \"\"\"Asynchronously delete a document.\n\n        Args:\n            document_id (str): The ID of the document to delete.\n        \"\"\"\n        r = await self.aclient.delete(f\"/documents/{document_id}\")\n        handle_response(r)\n        return r.json()\n\n    def bulk_delete_documents(\n        self, *, collection_name: str = None, collection_id: str = None\n    ) -&gt; dict:\n        \"\"\"Synchronously delete all documents from a collection.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            collection_name (str): The name of the collection to delete documents from.\n            collection_id (str): The ID of the collection to delete documents from. If\n                provided, `collection_name` will be ignored.\n\n        Raises:\n            ValueError: If neither `collection_name` nor `collection_id` are provided.\n        \"\"\"\n        if collection_id:\n            r = self.client.delete(f\"/collections/{collection_id}/documents\")\n        elif collection_name:\n            r = self.client.delete(\n                \"/documents\", params={\"collection_name\": collection_name}\n            )\n        else:\n            raise ValueError(\n                \"Either 'collection_name' or 'collection_id' must be provided\"\n            )\n        handle_response(r)\n        return r.json()\n\n    def upload_documents(\n        self,\n        files: str | Image.Image | list[str | Image.Image],\n        filenames: str | list[str] = None,\n        *,\n        collection_name: str = \"default\",\n        collection_id: str = None,\n        batch_size: int = 5,\n    ) -&gt; list[Document]:\n        \"\"\"Synchronously upload files to a collection in batches.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            files (str | Image.Image | list[str | Image.Image]): The files to upload.\n                Can be a single instance or a list of a string containing the path to\n                a file or an `Image.Image` object.\n            filenames (str | list[str], optional): The filenames of the files to\n                upload. Defaults to None.\n            collection_name (str): The name of the collection to upload the files to.\n                Defaults to \"default\".\n            collection_id (str): The ID of the collection to upload the files to.\n                Defaults to None. If provided, `collection_name` will be ignored.\n            batch_size (int): The number of files to upload in each batch. Defaults\n                to 5.\n\n        Returns:\n            Documents: A list of created documents.\n\n        Raises:\n            TypeError: If an input file type is invalid.\n            ValueError: If the length of the filenames list does not match the length\n                of the files list.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; lx.document.upload_documents(\n            ...     files=[\n            ...         'lexy/sample_data/images/lexy-dalle.jpeg',\n            ...         'lexy/sample_data/images/lexy.png',\n            ...         'dais2023-233180.pdf',\n            ...         'gwdemo30.mp4',\n            ...         'kindle2.html',\n            ...     ],\n            ...     collection_name='my_file_collection',\n            ... )\n        \"\"\"\n        created_docs = []\n        files, filenames = self._align_filenames(files, filenames)\n\n        # process and upload files in batches\n        for i in range(0, len(files), batch_size):\n            batch_files = files[i : i + batch_size]\n            batch_filenames = filenames[i : i + batch_size]\n            processed_files = self._process_files(\n                batch_files, filenames=batch_filenames\n            )\n\n            if collection_id is not None:\n                r = self.client.post(\n                    f\"/collections/{collection_id}/documents/upload\",\n                    files=processed_files,\n                )\n            else:\n                r = self.client.post(\n                    \"/documents/upload\",\n                    files=processed_files,\n                    params={\"collection_name\": collection_name},\n                )\n\n            handle_response(r)\n            created_docs.extend(\n                [\n                    Document(**document[\"document\"], client=self._lexy_client)\n                    for document in r.json()\n                ]\n            )\n        return created_docs\n\n    async def aupload_documents(\n        self,\n        files: str | Image.Image | list[str | Image.Image],\n        filenames: str | list[str] = None,\n        *,\n        collection_name: str = \"default\",\n        collection_id: str = None,\n        batch_size: int = 5,\n    ) -&gt; list[Document]:\n        \"\"\"Asynchronously upload files to a collection in batches.\n\n        If both `collection_name` and `collection_id` are provided, `collection_id`\n        will be used.\n\n        Args:\n            files (str | Image.Image | list[str | Image.Image]): The files to upload.\n                Can be a single instance or a list of a string containing the path to\n                a file or an `Image.Image` object.\n            filenames (str | list[str], optional): The filenames of the files to\n                upload. Defaults to None.\n            collection_name (str): The name of the collection to upload the files to.\n                Defaults to \"default\".\n            collection_id (str): The ID of the collection to upload the files to.\n                Defaults to None. If provided, `collection_name` will be ignored.\n            batch_size (int): The number of files to upload in each batch. Defaults\n                to 5.\n\n        Returns:\n            Documents: A list of created documents.\n\n        Raises:\n            TypeError: If an input file type is invalid.\n            ValueError: If the length of the filenames list does not match the length\n                of the files list.\n        \"\"\"\n        created_docs = []\n        files, filenames = self._align_filenames(files, filenames)\n\n        # process and upload files in batches\n        for i in range(0, len(files), batch_size):\n            batch_files = files[i : i + batch_size]\n            batch_filenames = filenames[i : i + batch_size]\n            processed_files = self._process_files(\n                batch_files, filenames=batch_filenames\n            )\n\n            if collection_id is not None:\n                r = await self.aclient.post(\n                    f\"/collections/{collection_id}/documents/upload\",\n                    files=processed_files,\n                )\n            else:\n                r = await self.aclient.post(\n                    \"/documents/upload\",\n                    files=processed_files,\n                    params={\"collection_name\": collection_name},\n                )\n\n            handle_response(r)\n            created_docs.extend(\n                [\n                    Document(**document[\"document\"], client=self._lexy_client)\n                    for document in r.json()\n                ]\n            )\n        return created_docs\n\n    def get_document_urls(self, document_id: str, *, expiration: int = 3600) -&gt; dict:\n        \"\"\"Synchronously get presigned URLs for a document.\n\n        Args:\n            document_id (str): The ID of the document to get presigned URL for.\n            expiration (int): The expiration time of the presigned URLs in seconds.\n                Defaults to 3600.\n\n        Returns:\n            dict: A dictionary containing presigned URLs.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; my_image_document = lx.list_documents('my_image_collection', limit=1)[0]\n            &gt;&gt;&gt; lx.document.get_document_urls(document_id=my_image_document.document_id)\n            {\n                \"object\": \"https://my-bucket.s3.amazonaws.com/path/to/object?...\",\n                \"thumbnails\": {\n                    \"256x256\": \"https://my-bucket.s3.amazonaws.com/path/to/thumbnail?...\"\n                }\n            }\n\n            &gt;&gt;&gt; my_pdf_document = lx.list_documents('pdf_collection', limit=1)[0]\n            &gt;&gt;&gt; lx.document.get_document_urls(document_id=my_pdf_document.document_id)\n            {\n                \"object\": \"https://my-bucket.s3.amazonaws.com/path/to/object?...\",\n            }\n        \"\"\"\n        r = self.client.get(\n            f\"/documents/{document_id}/urls\", params={\"expiration\": expiration}\n        )\n        handle_response(r)\n        return r.json()\n\n    async def aget_document_urls(\n        self, document_id: str, *, expiration: int = 3600\n    ) -&gt; dict:\n        \"\"\"Asynchronously get presigned URLs for a document.\n\n        Args:\n            document_id (str): The ID of the document to get presigned URL for.\n            expiration (int): The expiration time of the presigned URLs in seconds.\n                Defaults to 3600.\n\n        Returns:\n            dict: A dictionary containing presigned URLs.\n        \"\"\"\n        r = await self.aclient.get(\n            f\"/documents/{document_id}/urls\", params={\"expiration\": expiration}\n        )\n        handle_response(r)\n        return r.json()\n\n    @staticmethod\n    def _align_filenames(files, filenames: str | list[str] = None) -&gt; tuple[list, list]:\n        \"\"\"Align files and filenames.\"\"\"\n        # Ensure files is a list\n        if not isinstance(files, list):\n            files = [files]\n\n        # If filenames is a single string (or None), convert it to a list with repeated\n        # elements\n        if isinstance(filenames, str) or filenames is None:\n            filenames = [filenames] * len(files)\n\n        if len(files) != len(filenames):\n            raise ValueError(\"Length of filenames list must match length of files list\")\n        return files, filenames\n\n    @staticmethod\n    def _process_docs(docs: Document | dict | list[Document | dict]) -&gt; list[dict]:\n        \"\"\"Process documents into a list of json-serializable dictionaries.\"\"\"\n        processed_docs = []\n\n        if isinstance(docs, (Document, dict)):\n            docs = [docs]\n\n        for doc in docs:\n            if isinstance(doc, Document):\n                processed_docs.append(doc.model_dump(mode=\"json\"))\n            elif isinstance(doc, dict):\n                doc = Document(**doc)\n                processed_docs.append(doc.model_dump(mode=\"json\"))\n            else:\n                raise TypeError(\n                    f\"Invalid type for doc item: {type(doc)} - must be Document or dict\"\n                )\n\n        return processed_docs\n\n    @staticmethod\n    def _process_files(\n        files: str | Image.Image | list[str | Image.Image],\n        filenames: str | list[str] = None,\n    ) -&gt; list:\n        processed_files = []\n        files, filenames = DocumentClient._align_filenames(files, filenames)\n\n        for file, filename in zip(files, filenames):\n            if isinstance(file, str):\n                with open(file, \"rb\") as f:\n                    file_content = f.read()\n                if not filename:\n                    filename = os.path.basename(file)\n            elif isinstance(file, Image.Image):\n                buffer = BytesIO()\n                image_format = file.format or \"jpg\"\n                file.save(buffer, format=image_format)\n                buffer.seek(0)\n                file_content = buffer.getvalue()\n                if not filename:\n                    filename = (\n                        f\"image.{file.format.lower()}\" if file.format else \"image.jpg\"\n                    )\n            else:\n                raise TypeError(\n                    f\"Invalid type for file: {type(file)} - must be a str path to a \"\n                    f\"file, or an `Image.Image` object\"\n                )\n\n            mime_type = mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n            processed_files.append(\n                (\"files\", (filename, BytesIO(file_content), mime_type))\n            )\n\n        return processed_files\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.add_document","title":"<code>add_document(doc, *, collection_name='default', collection_id=None)</code>","text":"<p>Synchronously add a document to a collection.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>Document | dict</code> <p>The document to add.</p> required <code>collection_name</code> <code>str</code> <p>The name of the collection to add the document to. Defaults to \"default\".</p> <code>'default'</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to add the document to. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Document</code> <code>Document</code> <p>The created document.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>def add_document(\n    self,\n    doc: Document | dict,\n    *,\n    collection_name: str = \"default\",\n    collection_id: str = None,\n) -&gt; Document:\n    \"\"\"Synchronously add a document to a collection.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        doc (Document | dict): The document to add.\n        collection_name (str): The name of the collection to add the document to.\n            Defaults to \"default\".\n        collection_id (str): The ID of the collection to add the document to. If\n            provided, `collection_name` will be ignored.\n\n    Returns:\n        Document: The created document.\n    \"\"\"\n    processed_docs = self._process_docs(doc)\n\n    if collection_id is not None:\n        r = self.client.post(\n            f\"/collections/{collection_id}/documents\", json=processed_docs\n        )\n    else:\n        r = self.client.post(\n            \"/documents\",\n            json=processed_docs,\n            params={\"collection_name\": collection_name},\n        )\n\n    handle_response(r)\n    return Document(**r.json()[0][\"document\"], client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.add_documents","title":"<code>add_documents(docs, *, collection_name='default', collection_id=None, batch_size=100)</code>","text":"<p>Synchronously add documents to a collection in batches.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>docs</code> <code>Document | dict | list[Document | dict]</code> <p>The documents to add.</p> required <code>collection_name</code> <code>str</code> <p>The name of the collection to add the documents to. Defaults to \"default\".</p> <code>'default'</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to add the documents to. Defaults to None. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of documents to add in each batch. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>Documents</code> <code>list[Document]</code> <p>A list of created documents.</p> <p>Examples:</p> <p>Add documents to the default collection:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; docs_added = lx.add_documents(docs=[\n...     {\"content\": \"Default document 1\"},\n...     {\"content\": \"Default document 2\"}\n... ])\n</code></pre> <p>Add documents to a specific collection by name:</p> <pre><code>&gt;&gt;&gt; my_new_collection = lx.create_collection(\"my_new_collection\")\n&gt;&gt;&gt; docs_added = lx.add_documents(docs=[\n...     {\"content\": \"My first document\"},\n...     {\"content\": \"My second document\"}\n... ], collection_name=\"my_new_collection\")\n</code></pre> <p>Add documents to a specific collection by ID:</p> <pre><code>&gt;&gt;&gt; docs_added = lx.add_documents(docs=[\n...     {\"content\": \"My third document\"},\n...     {\"content\": \"My fourth document\"}\n... ], collection_id=my_new_collection.collection_id)\n</code></pre> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>def add_documents(\n    self,\n    docs: Document | dict | list[Document | dict],\n    *,\n    collection_name: str = \"default\",\n    collection_id: str = None,\n    batch_size: int = 100,\n) -&gt; list[Document]:\n    \"\"\"Synchronously add documents to a collection in batches.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        docs (Document | dict | list[Document | dict]): The documents to add.\n        collection_name (str): The name of the collection to add the documents to.\n            Defaults to \"default\".\n        collection_id (str): The ID of the collection to add the documents to.\n            Defaults to None. If provided, `collection_name` will be ignored.\n        batch_size (int): The number of documents to add in each batch. Defaults\n            to 100.\n\n    Returns:\n        Documents: A list of created documents.\n\n    Examples:\n        Add documents to the default collection:\n\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; docs_added = lx.add_documents(docs=[\n        ...     {\"content\": \"Default document 1\"},\n        ...     {\"content\": \"Default document 2\"}\n        ... ])\n\n        Add documents to a specific collection by name:\n\n        &gt;&gt;&gt; my_new_collection = lx.create_collection(\"my_new_collection\")\n        &gt;&gt;&gt; docs_added = lx.add_documents(docs=[\n        ...     {\"content\": \"My first document\"},\n        ...     {\"content\": \"My second document\"}\n        ... ], collection_name=\"my_new_collection\")\n\n        Add documents to a specific collection by ID:\n\n        &gt;&gt;&gt; docs_added = lx.add_documents(docs=[\n        ...     {\"content\": \"My third document\"},\n        ...     {\"content\": \"My fourth document\"}\n        ... ], collection_id=my_new_collection.collection_id)\n\n    \"\"\"\n    created_docs = []\n    processed_docs = self._process_docs(docs)\n\n    for i in range(0, len(processed_docs), batch_size):\n        batch_docs = processed_docs[i : i + batch_size]\n\n        if collection_id is not None:\n            r = self.client.post(\n                f\"/collections/{collection_id}/documents\", json=batch_docs\n            )\n        else:\n            r = self.client.post(\n                \"/documents\",\n                json=batch_docs,\n                params={\"collection_name\": collection_name},\n            )\n\n        handle_response(r)\n        created_docs.extend(\n            [\n                Document(**document[\"document\"], client=self._lexy_client)\n                for document in r.json()\n            ]\n        )\n    return created_docs\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.bulk_delete_documents","title":"<code>bulk_delete_documents(*, collection_name=None, collection_id=None)</code>","text":"<p>Synchronously delete all documents from a collection.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to delete documents from.</p> <code>None</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to delete documents from. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>collection_name</code> nor <code>collection_id</code> are provided.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>def bulk_delete_documents(\n    self, *, collection_name: str = None, collection_id: str = None\n) -&gt; dict:\n    \"\"\"Synchronously delete all documents from a collection.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        collection_name (str): The name of the collection to delete documents from.\n        collection_id (str): The ID of the collection to delete documents from. If\n            provided, `collection_name` will be ignored.\n\n    Raises:\n        ValueError: If neither `collection_name` nor `collection_id` are provided.\n    \"\"\"\n    if collection_id:\n        r = self.client.delete(f\"/collections/{collection_id}/documents\")\n    elif collection_name:\n        r = self.client.delete(\n            \"/documents\", params={\"collection_name\": collection_name}\n        )\n    else:\n        raise ValueError(\n            \"Either 'collection_name' or 'collection_id' must be provided\"\n        )\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.delete_document","title":"<code>delete_document(document_id)</code>","text":"<p>Synchronously delete a document.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>The ID of the document to delete.</p> required Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>def delete_document(self, document_id: str) -&gt; dict:\n    \"\"\"Synchronously delete a document.\n\n    Args:\n        document_id (str): The ID of the document to delete.\n    \"\"\"\n    r = self.client.delete(f\"/documents/{document_id}\")\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.get_document","title":"<code>get_document(document_id)</code>","text":"<p>Synchronously get a document.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>The ID of the document to get.</p> required <p>Returns:</p> Name Type Description <code>Document</code> <code>Document</code> <p>The document.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>def get_document(self, document_id: str) -&gt; Document:\n    \"\"\"Synchronously get a document.\n\n    Args:\n        document_id (str): The ID of the document to get.\n\n    Returns:\n        Document: The document.\n    \"\"\"\n    r = self.client.get(f\"/documents/{document_id}\")\n    handle_response(r)\n    return Document(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.get_document_urls","title":"<code>get_document_urls(document_id, *, expiration=3600)</code>","text":"<p>Synchronously get presigned URLs for a document.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>The ID of the document to get presigned URL for.</p> required <code>expiration</code> <code>int</code> <p>The expiration time of the presigned URLs in seconds. Defaults to 3600.</p> <code>3600</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing presigned URLs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; my_image_document = lx.list_documents('my_image_collection', limit=1)[0]\n&gt;&gt;&gt; lx.document.get_document_urls(document_id=my_image_document.document_id)\n{\n    \"object\": \"https://my-bucket.s3.amazonaws.com/path/to/object?...\",\n    \"thumbnails\": {\n        \"256x256\": \"https://my-bucket.s3.amazonaws.com/path/to/thumbnail?...\"\n    }\n}\n</code></pre> <pre><code>&gt;&gt;&gt; my_pdf_document = lx.list_documents('pdf_collection', limit=1)[0]\n&gt;&gt;&gt; lx.document.get_document_urls(document_id=my_pdf_document.document_id)\n{\n    \"object\": \"https://my-bucket.s3.amazonaws.com/path/to/object?...\",\n}\n</code></pre> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>def get_document_urls(self, document_id: str, *, expiration: int = 3600) -&gt; dict:\n    \"\"\"Synchronously get presigned URLs for a document.\n\n    Args:\n        document_id (str): The ID of the document to get presigned URL for.\n        expiration (int): The expiration time of the presigned URLs in seconds.\n            Defaults to 3600.\n\n    Returns:\n        dict: A dictionary containing presigned URLs.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; my_image_document = lx.list_documents('my_image_collection', limit=1)[0]\n        &gt;&gt;&gt; lx.document.get_document_urls(document_id=my_image_document.document_id)\n        {\n            \"object\": \"https://my-bucket.s3.amazonaws.com/path/to/object?...\",\n            \"thumbnails\": {\n                \"256x256\": \"https://my-bucket.s3.amazonaws.com/path/to/thumbnail?...\"\n            }\n        }\n\n        &gt;&gt;&gt; my_pdf_document = lx.list_documents('pdf_collection', limit=1)[0]\n        &gt;&gt;&gt; lx.document.get_document_urls(document_id=my_pdf_document.document_id)\n        {\n            \"object\": \"https://my-bucket.s3.amazonaws.com/path/to/object?...\",\n        }\n    \"\"\"\n    r = self.client.get(\n        f\"/documents/{document_id}/urls\", params={\"expiration\": expiration}\n    )\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.list_documents","title":"<code>list_documents(*, collection_name='default', collection_id=None, limit=100, offset=0)</code>","text":"<p>Synchronously get a list of documents in a collection.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to get documents from. Defaults to \"default\".</p> <code>'default'</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to get documents from. Defaults to None. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of documents to return. Defaults to 100. Maximum allowed is 1000.</p> <code>100</code> <code>offset</code> <code>int</code> <p>The offset to start from. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Documents</code> <code>list[Document]</code> <p>A list of documents in a collection.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>def list_documents(\n    self,\n    *,\n    collection_name: str | None = \"default\",\n    collection_id: str = None,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; list[Document]:\n    \"\"\"Synchronously get a list of documents in a collection.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        collection_name (str): The name of the collection to get documents from.\n            Defaults to \"default\".\n        collection_id (str): The ID of the collection to get documents from.\n            Defaults to None. If provided, `collection_name` will be ignored.\n        limit (int): The maximum number of documents to return. Defaults to 100.\n            Maximum allowed is 1000.\n        offset (int): The offset to start from. Defaults to 0.\n\n    Returns:\n        Documents: A list of documents in a collection.\n    \"\"\"\n    if collection_id is not None:\n        r = self.client.get(\n            f\"/collections/{collection_id}/documents\",\n            params={\"limit\": limit, \"offset\": offset},\n        )\n    else:\n        r = self.client.get(\n            \"/documents\",\n            params={\n                \"collection_name\": collection_name,\n                \"limit\": limit,\n                \"offset\": offset,\n            },\n        )\n    handle_response(r)\n    return [Document(**document, client=self._lexy_client) for document in r.json()]\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.update_document","title":"<code>update_document(document_id, *, content=None, meta=None)</code>","text":"<p>Synchronously update a document.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>The ID of the document to update.</p> required <code>content</code> <code>str</code> <p>The new content of the document.</p> <code>None</code> <code>meta</code> <code>dict</code> <p>The new metadata for the document.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Document</code> <code>Document</code> <p>The updated document.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>def update_document(\n    self,\n    document_id: str,\n    *,\n    content: Optional[str] = None,\n    meta: Optional[dict] = None,\n) -&gt; Document:\n    \"\"\"Synchronously update a document.\n\n    Args:\n        document_id (str): The ID of the document to update.\n        content (str, optional): The new content of the document.\n        meta (dict, optional): The new metadata for the document.\n\n    Returns:\n        Document: The updated document.\n    \"\"\"\n    document = DocumentUpdate(content=content, meta=meta)\n    r = self.client.patch(\n        f\"/documents/{document_id}\", json=document.model_dump(exclude_none=True)\n    )\n    handle_response(r)\n    return Document(**r.json()[\"document\"], client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.upload_documents","title":"<code>upload_documents(files, filenames=None, *, collection_name='default', collection_id=None, batch_size=5)</code>","text":"<p>Synchronously upload files to a collection in batches.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>str | Image | list[str | Image]</code> <p>The files to upload. Can be a single instance or a list of a string containing the path to a file or an <code>Image.Image</code> object.</p> required <code>filenames</code> <code>str | list[str]</code> <p>The filenames of the files to upload. Defaults to None.</p> <code>None</code> <code>collection_name</code> <code>str</code> <p>The name of the collection to upload the files to. Defaults to \"default\".</p> <code>'default'</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to upload the files to. Defaults to None. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of files to upload in each batch. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>Documents</code> <code>list[Document]</code> <p>A list of created documents.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If an input file type is invalid.</p> <code>ValueError</code> <p>If the length of the filenames list does not match the length of the files list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; lx.document.upload_documents(\n...     files=[\n...         'lexy/sample_data/images/lexy-dalle.jpeg',\n...         'lexy/sample_data/images/lexy.png',\n...         'dais2023-233180.pdf',\n...         'gwdemo30.mp4',\n...         'kindle2.html',\n...     ],\n...     collection_name='my_file_collection',\n... )\n</code></pre> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>def upload_documents(\n    self,\n    files: str | Image.Image | list[str | Image.Image],\n    filenames: str | list[str] = None,\n    *,\n    collection_name: str = \"default\",\n    collection_id: str = None,\n    batch_size: int = 5,\n) -&gt; list[Document]:\n    \"\"\"Synchronously upload files to a collection in batches.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        files (str | Image.Image | list[str | Image.Image]): The files to upload.\n            Can be a single instance or a list of a string containing the path to\n            a file or an `Image.Image` object.\n        filenames (str | list[str], optional): The filenames of the files to\n            upload. Defaults to None.\n        collection_name (str): The name of the collection to upload the files to.\n            Defaults to \"default\".\n        collection_id (str): The ID of the collection to upload the files to.\n            Defaults to None. If provided, `collection_name` will be ignored.\n        batch_size (int): The number of files to upload in each batch. Defaults\n            to 5.\n\n    Returns:\n        Documents: A list of created documents.\n\n    Raises:\n        TypeError: If an input file type is invalid.\n        ValueError: If the length of the filenames list does not match the length\n            of the files list.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; lx.document.upload_documents(\n        ...     files=[\n        ...         'lexy/sample_data/images/lexy-dalle.jpeg',\n        ...         'lexy/sample_data/images/lexy.png',\n        ...         'dais2023-233180.pdf',\n        ...         'gwdemo30.mp4',\n        ...         'kindle2.html',\n        ...     ],\n        ...     collection_name='my_file_collection',\n        ... )\n    \"\"\"\n    created_docs = []\n    files, filenames = self._align_filenames(files, filenames)\n\n    # process and upload files in batches\n    for i in range(0, len(files), batch_size):\n        batch_files = files[i : i + batch_size]\n        batch_filenames = filenames[i : i + batch_size]\n        processed_files = self._process_files(\n            batch_files, filenames=batch_filenames\n        )\n\n        if collection_id is not None:\n            r = self.client.post(\n                f\"/collections/{collection_id}/documents/upload\",\n                files=processed_files,\n            )\n        else:\n            r = self.client.post(\n                \"/documents/upload\",\n                files=processed_files,\n                params={\"collection_name\": collection_name},\n            )\n\n        handle_response(r)\n        created_docs.extend(\n            [\n                Document(**document[\"document\"], client=self._lexy_client)\n                for document in r.json()\n            ]\n        )\n    return created_docs\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.aadd_document","title":"<code>aadd_document(doc, *, collection_name='default', collection_id=None)</code>  <code>async</code>","text":"<p>Asynchronously add a document to a collection.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>Document | dict</code> <p>The document to add.</p> required <code>collection_name</code> <code>str</code> <p>The name of the collection to add the document to. Defaults to \"default\".</p> <code>'default'</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to add the document to. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Document</code> <code>Document</code> <p>The created document.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>async def aadd_document(\n    self,\n    doc: Document | dict,\n    *,\n    collection_name: str = \"default\",\n    collection_id: str = None,\n) -&gt; Document:\n    \"\"\"Asynchronously add a document to a collection.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        doc (Document | dict): The document to add.\n        collection_name (str): The name of the collection to add the document to.\n            Defaults to \"default\".\n        collection_id (str): The ID of the collection to add the document to. If\n            provided, `collection_name` will be ignored.\n\n    Returns:\n        Document: The created document.\n    \"\"\"\n    processed_docs = self._process_docs(doc)\n\n    if collection_id is not None:\n        r = await self.aclient.post(\n            f\"/collections/{collection_id}/documents\", json=processed_docs\n        )\n    else:\n        r = await self.aclient.post(\n            \"/documents\",\n            json=processed_docs,\n            params={\"collection_name\": collection_name},\n        )\n\n    handle_response(r)\n    return Document(**r.json()[0][\"document\"], client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.aadd_documents","title":"<code>aadd_documents(docs, *, collection_name='default', collection_id=None, batch_size=100)</code>  <code>async</code>","text":"<p>Asynchronously add documents to a collection in batches.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>docs</code> <code>Document | dict | list[Document | dict]</code> <p>The documents to add.</p> required <code>collection_name</code> <code>str</code> <p>The name of the collection to add the documents to. Defaults to \"default\".</p> <code>'default'</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to add the documents to. Defaults to None. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of documents to add in each batch. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>Documents</code> <code>list[Document]</code> <p>A list of created documents.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>async def aadd_documents(\n    self,\n    docs: Document | dict | list[Document | dict],\n    *,\n    collection_name: str = \"default\",\n    collection_id: str = None,\n    batch_size: int = 100,\n) -&gt; list[Document]:\n    \"\"\"Asynchronously add documents to a collection in batches.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        docs (Document | dict | list[Document | dict]): The documents to add.\n        collection_name (str): The name of the collection to add the documents to.\n            Defaults to \"default\".\n        collection_id (str): The ID of the collection to add the documents to.\n            Defaults to None. If provided, `collection_name` will be ignored.\n        batch_size (int): The number of documents to add in each batch. Defaults\n            to 100.\n\n    Returns:\n        Documents: A list of created documents.\n    \"\"\"\n    created_docs = []\n    processed_docs = self._process_docs(docs)\n\n    for i in range(0, len(processed_docs), batch_size):\n        batch_docs = processed_docs[i : i + batch_size]\n\n        if collection_id is not None:\n            r = await self.aclient.post(\n                f\"/collections/{collection_id}/documents\", json=batch_docs\n            )\n        else:\n            r = await self.aclient.post(\n                \"/documents\",\n                json=batch_docs,\n                params={\"collection_name\": collection_name},\n            )\n\n        handle_response(r)\n        created_docs.extend(\n            [\n                Document(**document[\"document\"], client=self._lexy_client)\n                for document in r.json()\n            ]\n        )\n    return created_docs\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.adelete_document","title":"<code>adelete_document(document_id)</code>  <code>async</code>","text":"<p>Asynchronously delete a document.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>The ID of the document to delete.</p> required Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>async def adelete_document(self, document_id: str) -&gt; dict:\n    \"\"\"Asynchronously delete a document.\n\n    Args:\n        document_id (str): The ID of the document to delete.\n    \"\"\"\n    r = await self.aclient.delete(f\"/documents/{document_id}\")\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.aget_document","title":"<code>aget_document(document_id)</code>  <code>async</code>","text":"<p>Asynchronously get a document.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>The ID of the document to get.</p> required <p>Returns:</p> Name Type Description <code>Document</code> <code>Document</code> <p>The document.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>async def aget_document(self, document_id: str) -&gt; Document:\n    \"\"\"Asynchronously get a document.\n\n    Args:\n        document_id (str): The ID of the document to get.\n\n    Returns:\n        Document: The document.\n    \"\"\"\n    r = await self.aclient.get(f\"/documents/{document_id}\")\n    handle_response(r)\n    return Document(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.aget_document_urls","title":"<code>aget_document_urls(document_id, *, expiration=3600)</code>  <code>async</code>","text":"<p>Asynchronously get presigned URLs for a document.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>The ID of the document to get presigned URL for.</p> required <code>expiration</code> <code>int</code> <p>The expiration time of the presigned URLs in seconds. Defaults to 3600.</p> <code>3600</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing presigned URLs.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>async def aget_document_urls(\n    self, document_id: str, *, expiration: int = 3600\n) -&gt; dict:\n    \"\"\"Asynchronously get presigned URLs for a document.\n\n    Args:\n        document_id (str): The ID of the document to get presigned URL for.\n        expiration (int): The expiration time of the presigned URLs in seconds.\n            Defaults to 3600.\n\n    Returns:\n        dict: A dictionary containing presigned URLs.\n    \"\"\"\n    r = await self.aclient.get(\n        f\"/documents/{document_id}/urls\", params={\"expiration\": expiration}\n    )\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.alist_documents","title":"<code>alist_documents(*, collection_name='default', collection_id=None, limit=100, offset=0)</code>  <code>async</code>","text":"<p>Asynchronously get a list of documents in a collection.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to get documents from. Defaults to \"default\".</p> <code>'default'</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to get documents from. Defaults to None. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of documents to return. Defaults to 100. Maximum allowed is 1000.</p> <code>100</code> <code>offset</code> <code>int</code> <p>The offset to start from. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Documents</code> <code>list[Document]</code> <p>A list of documents in a collection.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>async def alist_documents(\n    self,\n    *,\n    collection_name: str = \"default\",\n    collection_id: str = None,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; list[Document]:\n    \"\"\"Asynchronously get a list of documents in a collection.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        collection_name (str): The name of the collection to get documents from.\n            Defaults to \"default\".\n        collection_id (str): The ID of the collection to get documents from.\n            Defaults to None. If provided, `collection_name` will be ignored.\n        limit (int): The maximum number of documents to return. Defaults to 100.\n            Maximum allowed is 1000.\n        offset (int): The offset to start from. Defaults to 0.\n\n    Returns:\n        Documents: A list of documents in a collection.\n    \"\"\"\n    if collection_id is not None:\n        r = await self.aclient.get(\n            f\"/collections/{collection_id}/documents\",\n            params={\"limit\": limit, \"offset\": offset},\n        )\n    else:\n        r = await self.aclient.get(\n            \"/documents\",\n            params={\n                \"collection_name\": collection_name,\n                \"limit\": limit,\n                \"offset\": offset,\n            },\n        )\n    handle_response(r)\n    return [Document(**document, client=self._lexy_client) for document in r.json()]\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.aupdate_document","title":"<code>aupdate_document(document_id, *, content=None, meta=None)</code>  <code>async</code>","text":"<p>Asynchronously update a document.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>The ID of the document to update.</p> required <code>content</code> <code>str</code> <p>The new content of the document.</p> <code>None</code> <code>meta</code> <code>dict</code> <p>The new metadata for the document.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Document</code> <code>Document</code> <p>The updated document.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>async def aupdate_document(\n    self,\n    document_id: str,\n    *,\n    content: Optional[str] = None,\n    meta: Optional[dict] = None,\n) -&gt; Document:\n    \"\"\"Asynchronously update a document.\n\n    Args:\n        document_id (str): The ID of the document to update.\n        content (str, optional): The new content of the document.\n        meta (dict, optional): The new metadata for the document.\n\n    Returns:\n        Document: The updated document.\n    \"\"\"\n    document = DocumentUpdate(content=content, meta=meta)\n    r = await self.aclient.patch(\n        f\"/documents/{document_id}\", json=document.model_dump(exclude_none=True)\n    )\n    handle_response(r)\n    return Document(**r.json()[\"document\"], client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/document/#lexy_py.document.client.DocumentClient.aupload_documents","title":"<code>aupload_documents(files, filenames=None, *, collection_name='default', collection_id=None, batch_size=5)</code>  <code>async</code>","text":"<p>Asynchronously upload files to a collection in batches.</p> <p>If both <code>collection_name</code> and <code>collection_id</code> are provided, <code>collection_id</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>str | Image | list[str | Image]</code> <p>The files to upload. Can be a single instance or a list of a string containing the path to a file or an <code>Image.Image</code> object.</p> required <code>filenames</code> <code>str | list[str]</code> <p>The filenames of the files to upload. Defaults to None.</p> <code>None</code> <code>collection_name</code> <code>str</code> <p>The name of the collection to upload the files to. Defaults to \"default\".</p> <code>'default'</code> <code>collection_id</code> <code>str</code> <p>The ID of the collection to upload the files to. Defaults to None. If provided, <code>collection_name</code> will be ignored.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The number of files to upload in each batch. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>Documents</code> <code>list[Document]</code> <p>A list of created documents.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If an input file type is invalid.</p> <code>ValueError</code> <p>If the length of the filenames list does not match the length of the files list.</p> Source code in <code>sdk-python/lexy_py/document/client.py</code> <pre><code>async def aupload_documents(\n    self,\n    files: str | Image.Image | list[str | Image.Image],\n    filenames: str | list[str] = None,\n    *,\n    collection_name: str = \"default\",\n    collection_id: str = None,\n    batch_size: int = 5,\n) -&gt; list[Document]:\n    \"\"\"Asynchronously upload files to a collection in batches.\n\n    If both `collection_name` and `collection_id` are provided, `collection_id`\n    will be used.\n\n    Args:\n        files (str | Image.Image | list[str | Image.Image]): The files to upload.\n            Can be a single instance or a list of a string containing the path to\n            a file or an `Image.Image` object.\n        filenames (str | list[str], optional): The filenames of the files to\n            upload. Defaults to None.\n        collection_name (str): The name of the collection to upload the files to.\n            Defaults to \"default\".\n        collection_id (str): The ID of the collection to upload the files to.\n            Defaults to None. If provided, `collection_name` will be ignored.\n        batch_size (int): The number of files to upload in each batch. Defaults\n            to 5.\n\n    Returns:\n        Documents: A list of created documents.\n\n    Raises:\n        TypeError: If an input file type is invalid.\n        ValueError: If the length of the filenames list does not match the length\n            of the files list.\n    \"\"\"\n    created_docs = []\n    files, filenames = self._align_filenames(files, filenames)\n\n    # process and upload files in batches\n    for i in range(0, len(files), batch_size):\n        batch_files = files[i : i + batch_size]\n        batch_filenames = filenames[i : i + batch_size]\n        processed_files = self._process_files(\n            batch_files, filenames=batch_filenames\n        )\n\n        if collection_id is not None:\n            r = await self.aclient.post(\n                f\"/collections/{collection_id}/documents/upload\",\n                files=processed_files,\n            )\n        else:\n            r = await self.aclient.post(\n                \"/documents/upload\",\n                files=processed_files,\n                params={\"collection_name\": collection_name},\n            )\n\n        handle_response(r)\n        created_docs.extend(\n            [\n                Document(**document[\"document\"], client=self._lexy_client)\n                for document in r.json()\n            ]\n        )\n    return created_docs\n</code></pre>"},{"location":"reference/lexy_py/filters/","title":"Documentation for <code>FilterBuilder</code>","text":""},{"location":"reference/lexy_py/filters/#lexy_py.filters.FilterBuilder","title":"<code>lexy_py.filters.FilterBuilder</code>","text":"<p>Helper class for creating filters.</p> <p>Attributes:</p> Name Type Description <code>conditions</code> <code>list[dict]</code> <p>A list of conditions to be combined. Each condition consists of a field, an operation, a value, and a negation option. <code>field</code> is a string representing the field to be matched. <code>operation</code> is a string representing the operation to be performed on the field. <code>value</code> is the value to be matched against. <code>negate</code> is a boolean representing whether the condition should be negated.</p> <p>Valid operations include the following.</p> <ul> <li><code>equals</code></li> <li><code>equals_ci</code> (case-insensitive equals)</li> <li><code>less_than</code></li> <li><code>less_than_or_equals</code></li> <li><code>greater_than</code></li> <li><code>greater_than_or_equals</code></li> <li><code>contains</code></li> <li><code>contains_ci</code> (case-insensitive contains)</li> <li><code>starts_with</code></li> <li><code>starts_with_ci</code> (case-insensitive starts_with)</li> <li><code>ends_with</code></li> <li><code>ends_with_ci</code> (case-insensitive ends_with)</li> <li><code>in</code></li> </ul> <code>combination</code> <code>str</code> <p>The combination of conditions - either 'AND' or 'OR'</p> <p>Methods:</p> Name Description <code>include</code> <p>Adds a condition to the filter object with a positive match</p> <code>exclude</code> <p>Adds a condition to the filter object with a negative match</p> <code>to_dict</code> <p>Returns the filter object as a dictionary</p> <code>to_json</code> <p>Returns the filter object as a JSON string</p> <p>Examples:</p> <p>Restrict documents to those that contain the word 'mathematics' regardless of the case:</p> <pre><code>&gt;&gt;&gt; from lexy_py import FilterBuilder\n&gt;&gt;&gt; builder = FilterBuilder()\n&gt;&gt;&gt; builder.include(\"content\", \"contains_ci\", \"mathematics\")\n&gt;&gt;&gt; print(builder.to_json())\n{\n    \"conditions\": [\n        {\"field\": \"content\", \"operation\": \"contains_ci\", \"value\": \"mathematics\", \"negate\": false}\n    ],\n    \"combination\": \"AND\"\n}\n</code></pre> <p>Restrict documents to those with a size less than 30,000 bytes and a file type that is not an image or video:</p> <pre><code>&gt;&gt;&gt; builder = FilterBuilder()\n&gt;&gt;&gt; builder.include(\"meta.size\", \"less_than\", 30000)\n&gt;&gt;&gt; builder.exclude(\"meta.type\", \"in\", [\"image\", \"video\"])\n&gt;&gt;&gt; print(builder.to_json())\n{\n    \"conditions\": [\n        {\"field\": \"meta.size\", \"operation\": \"less_than\", \"value\": 30000, \"negate\": false},\n        {\"field\": \"meta.type\", \"operation\": \"in\", \"value\": [\"image\", \"video\"], \"negate\": true}\n    ],\n    \"combination\": \"AND\"\n}\n</code></pre> <p>Restrict documents to those where URL is not None and does not start with 'https://www.youtube.com':</p> <pre><code>&gt;&gt;&gt; builder = FilterBuilder()\n&gt;&gt;&gt; builder.exclude(\"meta.url\", \"starts_with\", \"https://www.youtube.com\")\n&gt;&gt;&gt; builder.exclude(\"meta.url\", \"equals\", None)\n&gt;&gt;&gt; builder.to_dict()\n{\n    \"conditions\": [\n        {\"field\": \"meta.url\", \"operation\": \"starts_with\", \"value\": \"https://www.youtube.com\", \"negate\": True},\n        {\"field\": \"meta.url\", \"operation\": \"equals\", \"value\": None, \"negate\": True}\n    ],\n    \"combination\": \"AND\"\n}\n</code></pre> Source code in <code>sdk-python/lexy_py/filters.py</code> <pre><code>class FilterBuilder:\n    \"\"\"Helper class for creating filters.\n\n    Attributes:\n        conditions (list[dict]): A list of conditions to be combined. Each condition\n            consists of a field, an operation, a value, and a negation option. `field`\n            is a string representing the field to be matched. `operation` is a string\n            representing the operation to be performed on the field. `value` is the\n            value to be matched against. `negate` is a boolean representing whether the\n            condition should be negated.\n\n            Valid operations include the following.\n\n            - `equals`\n            - `equals_ci` (case-insensitive equals)\n            - `less_than`\n            - `less_than_or_equals`\n            - `greater_than`\n            - `greater_than_or_equals`\n            - `contains`\n            - `contains_ci` (case-insensitive contains)\n            - `starts_with`\n            - `starts_with_ci` (case-insensitive starts_with)\n            - `ends_with`\n            - `ends_with_ci` (case-insensitive ends_with)\n            - `in`\n        combination (str): The combination of conditions - either 'AND' or 'OR'\n\n    Methods:\n        include: Adds a condition to the filter object with a positive match\n        exclude: Adds a condition to the filter object with a negative match\n        to_dict: Returns the filter object as a dictionary\n        to_json: Returns the filter object as a JSON string\n\n    Examples:\n        Restrict documents to those that contain the word 'mathematics' regardless of\n        the case:\n\n        &gt;&gt;&gt; from lexy_py import FilterBuilder\n        &gt;&gt;&gt; builder = FilterBuilder()\n        &gt;&gt;&gt; builder.include(\"content\", \"contains_ci\", \"mathematics\")\n        &gt;&gt;&gt; print(builder.to_json())\n        {\n            \"conditions\": [\n                {\"field\": \"content\", \"operation\": \"contains_ci\", \"value\": \"mathematics\", \"negate\": false}\n            ],\n            \"combination\": \"AND\"\n        }\n\n        Restrict documents to those with a size less than 30,000 bytes and a file type\n        that is not an image or video:\n\n        &gt;&gt;&gt; builder = FilterBuilder()\n        &gt;&gt;&gt; builder.include(\"meta.size\", \"less_than\", 30000)\n        &gt;&gt;&gt; builder.exclude(\"meta.type\", \"in\", [\"image\", \"video\"])\n        &gt;&gt;&gt; print(builder.to_json())\n        {\n            \"conditions\": [\n                {\"field\": \"meta.size\", \"operation\": \"less_than\", \"value\": 30000, \"negate\": false},\n                {\"field\": \"meta.type\", \"operation\": \"in\", \"value\": [\"image\", \"video\"], \"negate\": true}\n            ],\n            \"combination\": \"AND\"\n        }\n\n        Restrict documents to those where URL is not None and does not start with\n        'https://www.youtube.com':\n\n        &gt;&gt;&gt; builder = FilterBuilder()\n        &gt;&gt;&gt; builder.exclude(\"meta.url\", \"starts_with\", \"https://www.youtube.com\")\n        &gt;&gt;&gt; builder.exclude(\"meta.url\", \"equals\", None)\n        &gt;&gt;&gt; builder.to_dict()\n        {\n            \"conditions\": [\n                {\"field\": \"meta.url\", \"operation\": \"starts_with\", \"value\": \"https://www.youtube.com\", \"negate\": True},\n                {\"field\": \"meta.url\", \"operation\": \"equals\", \"value\": None, \"negate\": True}\n            ],\n            \"combination\": \"AND\"\n        }\n    \"\"\"\n\n    def __init__(self, conditions: list[dict] = None, combination: str = \"AND\"):\n        self.conditions = conditions or []\n        if combination.upper() not in [\"AND\", \"OR\"]:\n            raise ValueError(\"Invalid combination - must be 'AND' or 'OR'\")\n        self.combination = combination.upper()\n\n    def include(self, field: str, operation: str, value: Any):\n        \"\"\"Adds a condition to the filter object with a positive match\n\n        Args:\n            field: The field to be matched\n            operation: The operation to be performed on the field. Must be one of the\n                following.\n\n                - `equals`\n                - `equals_ci` (case-insensitive equals)\n                - `less_than`\n                - `less_than_or_equals`\n                - `greater_than`\n                - `greater_than_or_equals`\n                - `contains`\n                - `contains_ci` (case-insensitive contains)\n                - `starts_with`\n                - `starts_with_ci` (case-insensitive starts_with)\n                - `ends_with`\n                - `ends_with_ci` (case-insensitive ends_with)\n                - `in`\n            value: The value to be matched against\n        \"\"\"\n        self.conditions.append(\n            {\"field\": field, \"operation\": operation, \"value\": value, \"negate\": False}\n        )\n        return self\n\n    def exclude(self, field: str, operation: str, value: Any):\n        \"\"\"Adds a condition to the filter object with a negative match\n\n        Args:\n            field: The field to be matched\n            operation: The operation to be performed on the field. Must be one of the\n                following.\n\n                - `equals`\n                - `equals_ci` (case-insensitive equals)\n                - `less_than`\n                - `less_than_or_equals`\n                - `greater_than`\n                - `greater_than_or_equals`\n                - `contains`\n                - `contains_ci` (case-insensitive contains)\n                - `starts_with`\n                - `starts_with_ci` (case-insensitive starts_with)\n                - `ends_with`\n                - `ends_with_ci` (case-insensitive ends_with)\n                - `in`\n            value: The value to be matched against\n        \"\"\"\n        self.conditions.append(\n            {\"field\": field, \"operation\": operation, \"value\": value, \"negate\": True}\n        )\n        return self\n\n    def to_dict(self) -&gt; dict:\n        return {\"conditions\": self.conditions, \"combination\": self.combination}\n\n    def to_json(self) -&gt; str:\n        return json.dumps(\n            {\"conditions\": self.conditions, \"combination\": self.combination}\n        )\n</code></pre>"},{"location":"reference/lexy_py/filters/#lexy_py.filters.FilterBuilder.exclude","title":"<code>exclude(field, operation, value)</code>","text":"<p>Adds a condition to the filter object with a negative match</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The field to be matched</p> required <code>operation</code> <code>str</code> <p>The operation to be performed on the field. Must be one of the following.</p> <ul> <li><code>equals</code></li> <li><code>equals_ci</code> (case-insensitive equals)</li> <li><code>less_than</code></li> <li><code>less_than_or_equals</code></li> <li><code>greater_than</code></li> <li><code>greater_than_or_equals</code></li> <li><code>contains</code></li> <li><code>contains_ci</code> (case-insensitive contains)</li> <li><code>starts_with</code></li> <li><code>starts_with_ci</code> (case-insensitive starts_with)</li> <li><code>ends_with</code></li> <li><code>ends_with_ci</code> (case-insensitive ends_with)</li> <li><code>in</code></li> </ul> required <code>value</code> <code>Any</code> <p>The value to be matched against</p> required Source code in <code>sdk-python/lexy_py/filters.py</code> <pre><code>def exclude(self, field: str, operation: str, value: Any):\n    \"\"\"Adds a condition to the filter object with a negative match\n\n    Args:\n        field: The field to be matched\n        operation: The operation to be performed on the field. Must be one of the\n            following.\n\n            - `equals`\n            - `equals_ci` (case-insensitive equals)\n            - `less_than`\n            - `less_than_or_equals`\n            - `greater_than`\n            - `greater_than_or_equals`\n            - `contains`\n            - `contains_ci` (case-insensitive contains)\n            - `starts_with`\n            - `starts_with_ci` (case-insensitive starts_with)\n            - `ends_with`\n            - `ends_with_ci` (case-insensitive ends_with)\n            - `in`\n        value: The value to be matched against\n    \"\"\"\n    self.conditions.append(\n        {\"field\": field, \"operation\": operation, \"value\": value, \"negate\": True}\n    )\n    return self\n</code></pre>"},{"location":"reference/lexy_py/filters/#lexy_py.filters.FilterBuilder.include","title":"<code>include(field, operation, value)</code>","text":"<p>Adds a condition to the filter object with a positive match</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The field to be matched</p> required <code>operation</code> <code>str</code> <p>The operation to be performed on the field. Must be one of the following.</p> <ul> <li><code>equals</code></li> <li><code>equals_ci</code> (case-insensitive equals)</li> <li><code>less_than</code></li> <li><code>less_than_or_equals</code></li> <li><code>greater_than</code></li> <li><code>greater_than_or_equals</code></li> <li><code>contains</code></li> <li><code>contains_ci</code> (case-insensitive contains)</li> <li><code>starts_with</code></li> <li><code>starts_with_ci</code> (case-insensitive starts_with)</li> <li><code>ends_with</code></li> <li><code>ends_with_ci</code> (case-insensitive ends_with)</li> <li><code>in</code></li> </ul> required <code>value</code> <code>Any</code> <p>The value to be matched against</p> required Source code in <code>sdk-python/lexy_py/filters.py</code> <pre><code>def include(self, field: str, operation: str, value: Any):\n    \"\"\"Adds a condition to the filter object with a positive match\n\n    Args:\n        field: The field to be matched\n        operation: The operation to be performed on the field. Must be one of the\n            following.\n\n            - `equals`\n            - `equals_ci` (case-insensitive equals)\n            - `less_than`\n            - `less_than_or_equals`\n            - `greater_than`\n            - `greater_than_or_equals`\n            - `contains`\n            - `contains_ci` (case-insensitive contains)\n            - `starts_with`\n            - `starts_with_ci` (case-insensitive starts_with)\n            - `ends_with`\n            - `ends_with_ci` (case-insensitive ends_with)\n            - `in`\n        value: The value to be matched against\n    \"\"\"\n    self.conditions.append(\n        {\"field\": field, \"operation\": operation, \"value\": value, \"negate\": False}\n    )\n    return self\n</code></pre>"},{"location":"reference/lexy_py/indexes/","title":"Documentation for <code>Index</code>","text":""},{"location":"reference/lexy_py/indexes/#lexy_py.index.models.Index","title":"<code>lexy_py.index.models.Index</code>","text":"<p>             Bases: <code>IndexModel</code></p> <p>Index model</p> Source code in <code>sdk-python/lexy_py/index/models.py</code> <pre><code>class Index(IndexModel):\n    __doc__ = IndexModel.__doc__\n    _client: Optional[\"LexyClient\"] = PrivateAttr(default=None)\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        self._client = data.pop(\"client\", None)\n\n    @property\n    def client(self) -&gt; \"LexyClient\":\n        if not self._client:\n            raise ValueError(\"API client has not been set.\")\n        return self._client\n\n    def query(\n        self,\n        query_text: str = None,\n        query_image: Image.Image | str = None,\n        query_field: str = \"embedding\",\n        k: int = 5,\n        return_fields: list[str] = None,\n        return_document: bool = False,\n        embedding_model: str = None,\n    ) -&gt; list[dict]:\n        \"\"\"Synchronously query an index.\n\n        Args:\n            query_text (str): The query text.\n            query_image (Image.Image | str): The query image. Can be a PIL Image object\n                or a path to an image.\n            query_field (str, optional): The field to query. Defaults to \"embedding\".\n            k (int, optional): The number of records to return. Defaults to 5.\n            return_fields (list[str], optional): The fields to return. Defaults to\n                None, which returns all fields. To return fields from the linked\n                document, use \"document.&lt;field_name&gt;\".\n            return_document (bool, optional): Whether to return the document object.\n                Defaults to False.\n            embedding_model (str, optional): The name of the embedding model to use.\n                Defaults to None, which uses the embedding model associated with\n                `index_id.query_field`.\n\n        Returns:\n            Results: A list of query results.\n        \"\"\"\n        return self.client.index.query_index(\n            query_text=query_text,\n            query_image=query_image,\n            index_id=self.index_id,\n            query_field=query_field,\n            k=k,\n            return_fields=return_fields,\n            return_document=return_document,\n            embedding_model=embedding_model,\n        )\n\n    def list_records(self, document_id: Optional[str] = None) -&gt; list[dict]:\n        \"\"\"Synchronously list all records in the index.\n\n        Args:\n            document_id (str, optional): The document ID to filter by. Defaults to None.\n\n        Returns:\n            list[dict]: A list of records.\n        \"\"\"\n        return self.client.index.list_index_records(\n            self.index_id, document_id=document_id\n        )\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.models.Index.list_records","title":"<code>list_records(document_id=None)</code>","text":"<p>Synchronously list all records in the index.</p> <p>Parameters:</p> Name Type Description Default <code>document_id</code> <code>str</code> <p>The document ID to filter by. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: A list of records.</p> Source code in <code>sdk-python/lexy_py/index/models.py</code> <pre><code>def list_records(self, document_id: Optional[str] = None) -&gt; list[dict]:\n    \"\"\"Synchronously list all records in the index.\n\n    Args:\n        document_id (str, optional): The document ID to filter by. Defaults to None.\n\n    Returns:\n        list[dict]: A list of records.\n    \"\"\"\n    return self.client.index.list_index_records(\n        self.index_id, document_id=document_id\n    )\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.models.Index.query","title":"<code>query(query_text=None, query_image=None, query_field='embedding', k=5, return_fields=None, return_document=False, embedding_model=None)</code>","text":"<p>Synchronously query an index.</p> <p>Parameters:</p> Name Type Description Default <code>query_text</code> <code>str</code> <p>The query text.</p> <code>None</code> <code>query_image</code> <code>Image | str</code> <p>The query image. Can be a PIL Image object or a path to an image.</p> <code>None</code> <code>query_field</code> <code>str</code> <p>The field to query. Defaults to \"embedding\".</p> <code>'embedding'</code> <code>k</code> <code>int</code> <p>The number of records to return. Defaults to 5.</p> <code>5</code> <code>return_fields</code> <code>list[str]</code> <p>The fields to return. Defaults to None, which returns all fields. To return fields from the linked document, use \"document.\". <code>None</code> <code>return_document</code> <code>bool</code> <p>Whether to return the document object. Defaults to False.</p> <code>False</code> <code>embedding_model</code> <code>str</code> <p>The name of the embedding model to use. Defaults to None, which uses the embedding model associated with <code>index_id.query_field</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Results</code> <code>list[dict]</code> <p>A list of query results.</p> Source code in <code>sdk-python/lexy_py/index/models.py</code> <pre><code>def query(\n    self,\n    query_text: str = None,\n    query_image: Image.Image | str = None,\n    query_field: str = \"embedding\",\n    k: int = 5,\n    return_fields: list[str] = None,\n    return_document: bool = False,\n    embedding_model: str = None,\n) -&gt; list[dict]:\n    \"\"\"Synchronously query an index.\n\n    Args:\n        query_text (str): The query text.\n        query_image (Image.Image | str): The query image. Can be a PIL Image object\n            or a path to an image.\n        query_field (str, optional): The field to query. Defaults to \"embedding\".\n        k (int, optional): The number of records to return. Defaults to 5.\n        return_fields (list[str], optional): The fields to return. Defaults to\n            None, which returns all fields. To return fields from the linked\n            document, use \"document.&lt;field_name&gt;\".\n        return_document (bool, optional): Whether to return the document object.\n            Defaults to False.\n        embedding_model (str, optional): The name of the embedding model to use.\n            Defaults to None, which uses the embedding model associated with\n            `index_id.query_field`.\n\n    Returns:\n        Results: A list of query results.\n    \"\"\"\n    return self.client.index.query_index(\n        query_text=query_text,\n        query_image=query_image,\n        index_id=self.index_id,\n        query_field=query_field,\n        k=k,\n        return_fields=return_fields,\n        return_document=return_document,\n        embedding_model=embedding_model,\n    )\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.models.IndexModel","title":"<code>lexy_py.index.models.IndexModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Index model</p> <p>Parameters:</p> Name Type Description Default <code>index_id</code> <code>str</code> <p>The ID of the index.</p> required <code>description</code> <code>str | None</code> <code>None</code> <code>index_table_schema</code> <code>dict[str, Any] | None</code> <code>{}</code> <code>index_fields</code> <code>dict[str, Any] | None</code> <code>{}</code> <code>created_at</code> <code>datetime | None</code> <code>None</code> <code>updated_at</code> <code>datetime | None</code> <code>None</code> <code>index_table_name</code> <code>str | None</code> <code>None</code> Source code in <code>sdk-python/lexy_py/index/models.py</code> <pre><code>class IndexModel(BaseModel):\n    \"\"\"Index model\"\"\"\n\n    index_id: str = Field(\n        default=...,\n        min_length=1,\n        max_length=56,\n        pattern=\"^[a-z_][a-z0-9_]{0,55}$\",\n        description=\"The ID of the index.\",\n    )\n    description: Optional[str] = None\n    index_table_schema: Optional[dict[str, Any]] = Field(default={})\n    index_fields: Optional[dict[str, Any]] = Field(default={})\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n    index_table_name: Optional[str] = None\n\n    def __repr__(self):\n        return f\"&lt;Index('{self.index_id}', description='{self.description}')&gt;\"\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient","title":"<code>lexy_py.index.client.IndexClient</code>","text":"<p>This class is used to interact with the Lexy Indexes API.</p> <p>Attributes:</p> Name Type Description <code>aclient</code> <code>AsyncClient</code> <p>Asynchronous API client.</p> <code>client</code> <code>Client</code> <p>Synchronous API client.</p> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>class IndexClient:\n    \"\"\"\n    This class is used to interact with the Lexy Indexes API.\n\n    Attributes:\n        aclient (httpx.AsyncClient): Asynchronous API client.\n        client (httpx.Client): Synchronous API client.\n    \"\"\"\n\n    def __init__(self, lexy_client: \"LexyClient\") -&gt; None:\n        self._lexy_client = lexy_client\n\n    @property\n    def aclient(self) -&gt; httpx.AsyncClient:\n        return self._lexy_client.aclient\n\n    @property\n    def client(self) -&gt; httpx.Client:\n        return self._lexy_client.client\n\n    def list_indexes(self) -&gt; list[Index]:\n        \"\"\"Synchronously get a list of all indexes.\n\n        Returns:\n            list[Index]: A list of all indexes.\n        \"\"\"\n        r = self.client.get(\"/indexes\")\n        handle_response(r)\n        return [Index(**index, client=self._lexy_client) for index in r.json()]\n\n    async def alist_indexes(self) -&gt; list[Index]:\n        \"\"\"Asynchronously get a list of all indexes.\n\n        Returns:\n            list[Index]: A list of all indexes.\n        \"\"\"\n        r = await self.aclient.get(\"/indexes\")\n        handle_response(r)\n        return [Index(**index, client=self._lexy_client) for index in r.json()]\n\n    def get_index(self, index_id: str) -&gt; Index:\n        \"\"\"Synchronously get an index.\n\n        Args:\n            index_id (str): The ID of the index to get.\n\n        Returns:\n            Index: The index.\n        \"\"\"\n        r = self.client.get(f\"/indexes/{index_id}\")\n        handle_response(r)\n        return Index(**r.json(), client=self._lexy_client)\n\n    async def aget_index(self, index_id: str) -&gt; Index:\n        \"\"\"Asynchronously get an index.\n\n        Args:\n            index_id (str): The ID of the index to get.\n\n        Returns:\n            Index: The index.\n        \"\"\"\n        r = await self.aclient.get(f\"/indexes/{index_id}\")\n        handle_response(r)\n        return Index(**r.json(), client=self._lexy_client)\n\n    def create_index(\n        self,\n        index_id: str,\n        description: Optional[str] = None,\n        index_table_schema: Optional[dict[str, Any]] = None,\n        index_fields: Optional[dict[str, Any]] = None,\n    ) -&gt; Index:\n        \"\"\"Synchronously create an index.\n\n        Args:\n            index_id (str): The ID of the index to create.\n            description (str, optional): A description of the index. Defaults to None.\n            index_table_schema (dict[str, Any]): The schema of the index table.\n                Defaults to None.\n            index_fields (dict[str, Any]): The index fields that are created in the\n                index table. These are typically the fields you want to populate using\n                transformers. Defaults to None.\n\n        Returns:\n            Index: The index.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; code_index_fields = {\n            ...     \"code\": {\"type\": \"text\"},\n            ...     \"code_embedding\": {\"type\": \"embedding\", \"extras\": {\"dims\": 384, \"model\": \"text.embeddings.minilm\"}},\n            ...     \"n_lines\": {\"type\": \"int\"},\n            ... }\n            &gt;&gt;&gt; index = lx.index.create_index(index_id=\"code_index\",\n            ...                               description=\"Code embedding index\",\n            ...                               index_fields=code_index_fields)\n        \"\"\"\n        if index_table_schema is None:\n            index_table_schema = {}\n        if index_fields is None:\n            index_fields = {}\n        data = {\n            \"index_id\": index_id,\n            \"description\": description,\n            \"index_table_schema\": index_table_schema,\n            \"index_fields\": index_fields,\n        }\n        r = self.client.post(\"/indexes\", json=data)\n        handle_response(r)\n        return Index(**r.json(), client=self._lexy_client)\n\n    async def acreate_index(\n        self,\n        index_id: str,\n        description: Optional[str] = None,\n        index_table_schema: Optional[dict[str, Any]] = None,\n        index_fields: Optional[dict[str, Any]] = None,\n    ) -&gt; Index:\n        \"\"\"Asynchronously create an index.\n\n        Args:\n            index_id (str): The ID of the index to create.\n            description (str, optional): A description of the index. Defaults to None.\n            index_table_schema (dict[str, Any]): The schema of the index table.\n                Defaults to None.\n            index_fields (dict[str, Any]): The index fields that are created in the\n                index table. These are typically the fields you want to populate using\n                transformers. Defaults to None.\n\n        Returns:\n            Index: The index.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; code_index_fields = {\n            ...     \"code\": {\"type\": \"text\"},\n            ...     \"code_embedding\": {\"type\": \"embedding\", \"extras\": {\"dims\": 384, \"model\": \"text.embeddings.minilm\"}},\n            ...     \"n_lines\": {\"type\": \"int\"},\n            ... }\n            &gt;&gt;&gt; index = await lx.index.acreate_index(index_id=\"code_index\",\n            ...                                      description=\"Code embedding index\",\n            ...                                      index_fields=code_index_fields)\n        \"\"\"\n        if index_table_schema is None:\n            index_table_schema = {}\n        if index_fields is None:\n            index_fields = {}\n        data = {\n            \"index_id\": index_id,\n            \"description\": description,\n            \"index_table_schema\": index_table_schema,\n            \"index_fields\": index_fields,\n        }\n        r = await self.aclient.post(\"/indexes\", json=data)\n        handle_response(r)\n        return Index(**r.json(), client=self._lexy_client)\n\n    def delete_index(self, index_id: str, drop_table: bool = False) -&gt; dict:\n        \"\"\"Synchronously delete an index.\n\n        Args:\n            index_id (str): The ID of the index to delete.\n            drop_table (bool, optional): Whether to drop the index table from the\n                database. Defaults to False.\n        \"\"\"\n        r = self.client.delete(\n            f\"/indexes/{index_id}\", params={\"drop_table\": drop_table}\n        )\n        handle_response(r)\n        return r.json()\n\n    async def adelete_index(self, index_id: str, drop_table: bool = False) -&gt; dict:\n        \"\"\"Asynchronously delete an index.\n\n        Args:\n            index_id (str): The ID of the index to delete.\n            drop_table (bool, optional): Whether to drop the index table from the\n                database. Defaults to False.\n        \"\"\"\n        r = await self.aclient.delete(\n            f\"/indexes/{index_id}\", params={\"drop_table\": drop_table}\n        )\n        handle_response(r)\n        return r.json()\n\n    def update_index(\n        self,\n        index_id: str,\n        description: Optional[str] = None,\n        index_table_schema: Optional[dict[str, Any]] = None,\n        index_fields: Optional[dict[str, Any]] = None,\n    ) -&gt; Index:\n        \"\"\"Synchronously update an index.\n\n        Args:\n            index_id (str): The ID of the index to update.\n            description (str, optional): The new description of the index.\n            index_table_schema (dict[str, Any], optional): The new schema of the index\n                table.\n            index_fields (dict[str, Any], optional): The new value for index fields\n                that are created in the index table.\n\n        Returns:\n            Index: The updated index.\n        \"\"\"\n        index = IndexUpdate(\n            description=description,\n            index_table_schema=index_table_schema,\n            index_fields=index_fields,\n        )\n        r = self.client.patch(\n            f\"/indexes/{index_id}\", json=index.model_dump(exclude_none=True)\n        )\n        handle_response(r)\n        return Index(**r.json(), client=self._lexy_client)\n\n    async def aupdate_index(\n        self,\n        index_id: str,\n        description: Optional[str] = None,\n        index_table_schema: Optional[dict[str, Any]] = None,\n        index_fields: Optional[dict[str, Any]] = None,\n    ) -&gt; Index:\n        \"\"\"Asynchronously update an index.\n\n        Args:\n            index_id (str): The ID of the index to update.\n            description (str, optional): The new description of the index.\n            index_table_schema (dict[str, Any], optional): The new schema of the index\n                table.\n            index_fields (dict[str, Any], optional): The new value for index fields\n                that are created in the index table.\n\n        Returns:\n            Index: The updated index.\n        \"\"\"\n        index = IndexUpdate(\n            description=description,\n            index_table_schema=index_table_schema,\n            index_fields=index_fields,\n        )\n        r = await self.aclient.patch(\n            f\"/indexes/{index_id}\", json=index.model_dump(exclude_none=True)\n        )\n        handle_response(r)\n        return Index(**r.json(), client=self._lexy_client)\n\n    def list_index_records(\n        self, index_id: str, document_id: Optional[str] = None\n    ) -&gt; list[dict]:\n        \"\"\"Synchronously get a list of all index records for an index.\n\n        Args:\n            index_id (str): The ID of the index to get records for.\n            document_id (str, optional): The ID of a document to get records for.\n\n        Returns:\n            list[dict]: A list of all index records for an index.\n        \"\"\"\n        params = {}\n        if document_id:\n            params[\"document_id\"] = document_id\n        r = self.client.get(f\"/indexes/{index_id}/records\", params=params)\n        handle_response(r)\n        return r.json()\n\n    async def alist_index_records(\n        self, index_id: str, document_id: Optional[str] = None\n    ) -&gt; list[dict]:\n        \"\"\"Asynchronously get a list of all index records for an index.\n\n        Args:\n            index_id (str): The ID of the index to get records for.\n            document_id (str, optional): The ID of a document to get records for.\n\n        Returns:\n            list[dict]: A list of all index records for an index.\n        \"\"\"\n        params = {}\n        if document_id:\n            params[\"document_id\"] = document_id\n        r = await self.aclient.get(f\"/indexes/{index_id}/records\", params=params)\n        handle_response(r)\n        return r.json()\n\n    def query_index(\n        self,\n        query_text: str = None,\n        query_image: Image.Image | str = None,\n        index_id: str = \"default_text_embeddings\",\n        query_field: str = \"embedding\",\n        k: int = 5,\n        return_fields: list[str] = None,\n        return_document: bool = False,\n        embedding_model: str = None,\n    ) -&gt; list[dict]:\n        \"\"\"Synchronously query an index.\n\n        Args:\n            query_text (str): The query text.\n            query_image (Image.Image | str): The query image. Can be a PIL Image object\n                or a path to an image.\n            index_id (str): The ID of the index to query. Defaults to\n                \"default_text_embeddings\".\n            query_field (str, optional): The field to query. Defaults to \"embedding\".\n            k (int, optional): The number of records to return. Defaults to 5.\n            return_fields (list[str], optional): The fields to return. Defaults to\n                None, which returns all fields. To return fields from the linked\n                document, use \"document.&lt;field_name&gt;\".\n            return_document (bool, optional): Whether to return the document object.\n                Defaults to False.\n            embedding_model (str, optional): The name of the embedding model to use.\n                Defaults to None, which uses the embedding model associated with\n                `index_id.query_field`.\n\n        Returns:\n            list[dict]: The query results.\n\n        Examples:\n            Query an index using text:\n\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; lx.query_index(query_text=\"Test Query\")\n\n            Query an index using text and return specific fields:\n\n            &gt;&gt;&gt; lx.query_index(\n            ...     query_text=\"Test Query\",\n            ...     return_fields=[\"my_index_field\", \"document.content\"]\n            ... )\n\n            Query an index using an image file:\n\n            &gt;&gt;&gt; lx.query_index(query_image=\"test_image.jpg\", index_id=\"my_image_index\")\n\n            Query an index using a PIL Image object:\n\n            &gt;&gt;&gt; import httpx\n            &gt;&gt;&gt; from PIL import Image\n            &gt;&gt;&gt; img_url = 'https://getlexy.com/assets/images/dalle-agi.jpeg'\n            &gt;&gt;&gt; image = Image.open(httpx.get(img_url))\n            &gt;&gt;&gt; lx.query_index(query_image=image, index_id=\"my_image_index\", k=3)\n        \"\"\"\n        files, params = self._process_query_params(\n            query_text=query_text,\n            query_image=query_image,\n            query_field=query_field,\n            k=k,\n            return_fields=return_fields,\n            return_document=return_document,\n            embedding_model=embedding_model,\n        )\n\n        r = self.client.post(\n            f\"/indexes/{index_id}/records/query\", files=files, params=params\n        )\n        handle_response(r)\n        search_results = r.json()[\"search_results\"]\n        if return_document:\n            for result in search_results:\n                result[\"document\"] = Document(\n                    **result[\"document\"], client=self._lexy_client\n                )\n        return search_results\n\n    async def aquery_index(\n        self,\n        query_text: str = None,\n        query_image: Image.Image | str = None,\n        index_id: str = \"default_text_embeddings\",\n        query_field: str = \"embedding\",\n        k: int = 5,\n        return_fields: list[str] = None,\n        return_document: bool = False,\n        embedding_model: str = None,\n    ) -&gt; list[dict]:\n        \"\"\"Asynchronously query an index.\n\n        Args:\n            query_text (str): The query text.\n            query_image (Image.Image | str): The query image. Can be a PIL Image object\n                or a path to an image.\n            index_id (str): The ID of the index to query. Defaults to\n                \"default_text_embeddings\".\n            query_field (str, optional): The field to query. Defaults to \"embedding\".\n            k (int, optional): The number of records to return. Defaults to 5.\n            return_fields (list[str], optional): The fields to return. Defaults to\n                None, which returns all fields. To return fields from the linked\n                document, use \"document.&lt;field_name&gt;\".\n            return_document (bool, optional): Whether to return the document object.\n                Defaults to False.\n            embedding_model (str, optional): The name of the embedding model to use.\n                Defaults to None, which uses the embedding model associated with\n                `index_id.query_field`.\n\n        Returns:\n            list[dict]: The query results.\n        \"\"\"\n        files, params = self._process_query_params(\n            query_text=query_text,\n            query_image=query_image,\n            query_field=query_field,\n            k=k,\n            return_fields=return_fields,\n            return_document=return_document,\n            embedding_model=embedding_model,\n        )\n\n        r = await self.aclient.post(\n            f\"/indexes/{index_id}/records/query\", files=files, params=params\n        )\n        handle_response(r)\n        search_results = r.json()[\"search_results\"]\n        if return_document:\n            for result in search_results:\n                result[\"document\"] = Document(\n                    **result[\"document\"], client=self._lexy_client\n                )\n        return search_results\n\n    @staticmethod\n    def _process_query_params(\n        query_text: str,\n        query_image: Image.Image | str,\n        query_field: str,\n        k: int,\n        return_fields: list[str],\n        return_document: bool,\n        embedding_model: str,\n    ) -&gt; tuple[dict, dict]:\n        files = {}\n\n        if query_text and query_image:\n            raise LexyClientError(\n                \"Please submit either 'query_text' or 'query_image', not both.\"\n            )\n        elif query_text:\n            files[\"query_text\"] = (None, query_text)\n        elif query_image:\n            if isinstance(query_image, str):\n                image = Image.open(query_image)\n                filename = os.path.basename(query_image)\n            else:\n                image = query_image\n                filename = (\n                    f\"image.{image.format.lower()}\" if image.format else \"image.jpg\"\n                )\n            buffer = io.BytesIO()\n            image_format = image.format or \"jpg\"\n            image.save(buffer, format=image_format)\n            buffer.seek(0)\n            mime_type = mimetypes.types_map.get(\n                f\".{image_format.lower()}\", \"application/octet-stream\"\n            )\n            files[\"query_image\"] = (filename, buffer, mime_type)\n        else:\n            raise LexyClientError(\"Please submit either 'query_text' or 'query_image'.\")\n\n        if return_fields is None:\n            return_fields = []\n        params = {\n            \"query_field\": query_field,\n            \"k\": k,\n            \"return_fields\": return_fields,\n            \"return_document\": return_document,\n        }\n        if embedding_model:\n            params[\"embedding_model\"] = embedding_model\n\n        return files, params\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.create_index","title":"<code>create_index(index_id, description=None, index_table_schema=None, index_fields=None)</code>","text":"<p>Synchronously create an index.</p> <p>Parameters:</p> Name Type Description Default <code>index_id</code> <code>str</code> <p>The ID of the index to create.</p> required <code>description</code> <code>str</code> <p>A description of the index. Defaults to None.</p> <code>None</code> <code>index_table_schema</code> <code>dict[str, Any]</code> <p>The schema of the index table. Defaults to None.</p> <code>None</code> <code>index_fields</code> <code>dict[str, Any]</code> <p>The index fields that are created in the index table. These are typically the fields you want to populate using transformers. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Index</code> <code>Index</code> <p>The index.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; code_index_fields = {\n...     \"code\": {\"type\": \"text\"},\n...     \"code_embedding\": {\"type\": \"embedding\", \"extras\": {\"dims\": 384, \"model\": \"text.embeddings.minilm\"}},\n...     \"n_lines\": {\"type\": \"int\"},\n... }\n&gt;&gt;&gt; index = lx.index.create_index(index_id=\"code_index\",\n...                               description=\"Code embedding index\",\n...                               index_fields=code_index_fields)\n</code></pre> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>def create_index(\n    self,\n    index_id: str,\n    description: Optional[str] = None,\n    index_table_schema: Optional[dict[str, Any]] = None,\n    index_fields: Optional[dict[str, Any]] = None,\n) -&gt; Index:\n    \"\"\"Synchronously create an index.\n\n    Args:\n        index_id (str): The ID of the index to create.\n        description (str, optional): A description of the index. Defaults to None.\n        index_table_schema (dict[str, Any]): The schema of the index table.\n            Defaults to None.\n        index_fields (dict[str, Any]): The index fields that are created in the\n            index table. These are typically the fields you want to populate using\n            transformers. Defaults to None.\n\n    Returns:\n        Index: The index.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; code_index_fields = {\n        ...     \"code\": {\"type\": \"text\"},\n        ...     \"code_embedding\": {\"type\": \"embedding\", \"extras\": {\"dims\": 384, \"model\": \"text.embeddings.minilm\"}},\n        ...     \"n_lines\": {\"type\": \"int\"},\n        ... }\n        &gt;&gt;&gt; index = lx.index.create_index(index_id=\"code_index\",\n        ...                               description=\"Code embedding index\",\n        ...                               index_fields=code_index_fields)\n    \"\"\"\n    if index_table_schema is None:\n        index_table_schema = {}\n    if index_fields is None:\n        index_fields = {}\n    data = {\n        \"index_id\": index_id,\n        \"description\": description,\n        \"index_table_schema\": index_table_schema,\n        \"index_fields\": index_fields,\n    }\n    r = self.client.post(\"/indexes\", json=data)\n    handle_response(r)\n    return Index(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.delete_index","title":"<code>delete_index(index_id, drop_table=False)</code>","text":"<p>Synchronously delete an index.</p> <p>Parameters:</p> Name Type Description Default <code>index_id</code> <code>str</code> <p>The ID of the index to delete.</p> required <code>drop_table</code> <code>bool</code> <p>Whether to drop the index table from the database. Defaults to False.</p> <code>False</code> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>def delete_index(self, index_id: str, drop_table: bool = False) -&gt; dict:\n    \"\"\"Synchronously delete an index.\n\n    Args:\n        index_id (str): The ID of the index to delete.\n        drop_table (bool, optional): Whether to drop the index table from the\n            database. Defaults to False.\n    \"\"\"\n    r = self.client.delete(\n        f\"/indexes/{index_id}\", params={\"drop_table\": drop_table}\n    )\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.get_index","title":"<code>get_index(index_id)</code>","text":"<p>Synchronously get an index.</p> <p>Parameters:</p> Name Type Description Default <code>index_id</code> <code>str</code> <p>The ID of the index to get.</p> required <p>Returns:</p> Name Type Description <code>Index</code> <code>Index</code> <p>The index.</p> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>def get_index(self, index_id: str) -&gt; Index:\n    \"\"\"Synchronously get an index.\n\n    Args:\n        index_id (str): The ID of the index to get.\n\n    Returns:\n        Index: The index.\n    \"\"\"\n    r = self.client.get(f\"/indexes/{index_id}\")\n    handle_response(r)\n    return Index(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.list_indexes","title":"<code>list_indexes()</code>","text":"<p>Synchronously get a list of all indexes.</p> <p>Returns:</p> Type Description <code>list[Index]</code> <p>list[Index]: A list of all indexes.</p> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>def list_indexes(self) -&gt; list[Index]:\n    \"\"\"Synchronously get a list of all indexes.\n\n    Returns:\n        list[Index]: A list of all indexes.\n    \"\"\"\n    r = self.client.get(\"/indexes\")\n    handle_response(r)\n    return [Index(**index, client=self._lexy_client) for index in r.json()]\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.query_index","title":"<code>query_index(query_text=None, query_image=None, index_id='default_text_embeddings', query_field='embedding', k=5, return_fields=None, return_document=False, embedding_model=None)</code>","text":"<p>Synchronously query an index.</p> <p>Parameters:</p> Name Type Description Default <code>query_text</code> <code>str</code> <p>The query text.</p> <code>None</code> <code>query_image</code> <code>Image | str</code> <p>The query image. Can be a PIL Image object or a path to an image.</p> <code>None</code> <code>index_id</code> <code>str</code> <p>The ID of the index to query. Defaults to \"default_text_embeddings\".</p> <code>'default_text_embeddings'</code> <code>query_field</code> <code>str</code> <p>The field to query. Defaults to \"embedding\".</p> <code>'embedding'</code> <code>k</code> <code>int</code> <p>The number of records to return. Defaults to 5.</p> <code>5</code> <code>return_fields</code> <code>list[str]</code> <p>The fields to return. Defaults to None, which returns all fields. To return fields from the linked document, use \"document.\". <code>None</code> <code>return_document</code> <code>bool</code> <p>Whether to return the document object. Defaults to False.</p> <code>False</code> <code>embedding_model</code> <code>str</code> <p>The name of the embedding model to use. Defaults to None, which uses the embedding model associated with <code>index_id.query_field</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: The query results.</p> <p>Examples:</p> <p>Query an index using text:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; lx.query_index(query_text=\"Test Query\")\n</code></pre> <p>Query an index using text and return specific fields:</p> <pre><code>&gt;&gt;&gt; lx.query_index(\n...     query_text=\"Test Query\",\n...     return_fields=[\"my_index_field\", \"document.content\"]\n... )\n</code></pre> <p>Query an index using an image file:</p> <pre><code>&gt;&gt;&gt; lx.query_index(query_image=\"test_image.jpg\", index_id=\"my_image_index\")\n</code></pre> <p>Query an index using a PIL Image object:</p> <pre><code>&gt;&gt;&gt; import httpx\n&gt;&gt;&gt; from PIL import Image\n&gt;&gt;&gt; img_url = 'https://getlexy.com/assets/images/dalle-agi.jpeg'\n&gt;&gt;&gt; image = Image.open(httpx.get(img_url))\n&gt;&gt;&gt; lx.query_index(query_image=image, index_id=\"my_image_index\", k=3)\n</code></pre> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>def query_index(\n    self,\n    query_text: str = None,\n    query_image: Image.Image | str = None,\n    index_id: str = \"default_text_embeddings\",\n    query_field: str = \"embedding\",\n    k: int = 5,\n    return_fields: list[str] = None,\n    return_document: bool = False,\n    embedding_model: str = None,\n) -&gt; list[dict]:\n    \"\"\"Synchronously query an index.\n\n    Args:\n        query_text (str): The query text.\n        query_image (Image.Image | str): The query image. Can be a PIL Image object\n            or a path to an image.\n        index_id (str): The ID of the index to query. Defaults to\n            \"default_text_embeddings\".\n        query_field (str, optional): The field to query. Defaults to \"embedding\".\n        k (int, optional): The number of records to return. Defaults to 5.\n        return_fields (list[str], optional): The fields to return. Defaults to\n            None, which returns all fields. To return fields from the linked\n            document, use \"document.&lt;field_name&gt;\".\n        return_document (bool, optional): Whether to return the document object.\n            Defaults to False.\n        embedding_model (str, optional): The name of the embedding model to use.\n            Defaults to None, which uses the embedding model associated with\n            `index_id.query_field`.\n\n    Returns:\n        list[dict]: The query results.\n\n    Examples:\n        Query an index using text:\n\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; lx.query_index(query_text=\"Test Query\")\n\n        Query an index using text and return specific fields:\n\n        &gt;&gt;&gt; lx.query_index(\n        ...     query_text=\"Test Query\",\n        ...     return_fields=[\"my_index_field\", \"document.content\"]\n        ... )\n\n        Query an index using an image file:\n\n        &gt;&gt;&gt; lx.query_index(query_image=\"test_image.jpg\", index_id=\"my_image_index\")\n\n        Query an index using a PIL Image object:\n\n        &gt;&gt;&gt; import httpx\n        &gt;&gt;&gt; from PIL import Image\n        &gt;&gt;&gt; img_url = 'https://getlexy.com/assets/images/dalle-agi.jpeg'\n        &gt;&gt;&gt; image = Image.open(httpx.get(img_url))\n        &gt;&gt;&gt; lx.query_index(query_image=image, index_id=\"my_image_index\", k=3)\n    \"\"\"\n    files, params = self._process_query_params(\n        query_text=query_text,\n        query_image=query_image,\n        query_field=query_field,\n        k=k,\n        return_fields=return_fields,\n        return_document=return_document,\n        embedding_model=embedding_model,\n    )\n\n    r = self.client.post(\n        f\"/indexes/{index_id}/records/query\", files=files, params=params\n    )\n    handle_response(r)\n    search_results = r.json()[\"search_results\"]\n    if return_document:\n        for result in search_results:\n            result[\"document\"] = Document(\n                **result[\"document\"], client=self._lexy_client\n            )\n    return search_results\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.update_index","title":"<code>update_index(index_id, description=None, index_table_schema=None, index_fields=None)</code>","text":"<p>Synchronously update an index.</p> <p>Parameters:</p> Name Type Description Default <code>index_id</code> <code>str</code> <p>The ID of the index to update.</p> required <code>description</code> <code>str</code> <p>The new description of the index.</p> <code>None</code> <code>index_table_schema</code> <code>dict[str, Any]</code> <p>The new schema of the index table.</p> <code>None</code> <code>index_fields</code> <code>dict[str, Any]</code> <p>The new value for index fields that are created in the index table.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Index</code> <code>Index</code> <p>The updated index.</p> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>def update_index(\n    self,\n    index_id: str,\n    description: Optional[str] = None,\n    index_table_schema: Optional[dict[str, Any]] = None,\n    index_fields: Optional[dict[str, Any]] = None,\n) -&gt; Index:\n    \"\"\"Synchronously update an index.\n\n    Args:\n        index_id (str): The ID of the index to update.\n        description (str, optional): The new description of the index.\n        index_table_schema (dict[str, Any], optional): The new schema of the index\n            table.\n        index_fields (dict[str, Any], optional): The new value for index fields\n            that are created in the index table.\n\n    Returns:\n        Index: The updated index.\n    \"\"\"\n    index = IndexUpdate(\n        description=description,\n        index_table_schema=index_table_schema,\n        index_fields=index_fields,\n    )\n    r = self.client.patch(\n        f\"/indexes/{index_id}\", json=index.model_dump(exclude_none=True)\n    )\n    handle_response(r)\n    return Index(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.acreate_index","title":"<code>acreate_index(index_id, description=None, index_table_schema=None, index_fields=None)</code>  <code>async</code>","text":"<p>Asynchronously create an index.</p> <p>Parameters:</p> Name Type Description Default <code>index_id</code> <code>str</code> <p>The ID of the index to create.</p> required <code>description</code> <code>str</code> <p>A description of the index. Defaults to None.</p> <code>None</code> <code>index_table_schema</code> <code>dict[str, Any]</code> <p>The schema of the index table. Defaults to None.</p> <code>None</code> <code>index_fields</code> <code>dict[str, Any]</code> <p>The index fields that are created in the index table. These are typically the fields you want to populate using transformers. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Index</code> <code>Index</code> <p>The index.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; code_index_fields = {\n...     \"code\": {\"type\": \"text\"},\n...     \"code_embedding\": {\"type\": \"embedding\", \"extras\": {\"dims\": 384, \"model\": \"text.embeddings.minilm\"}},\n...     \"n_lines\": {\"type\": \"int\"},\n... }\n&gt;&gt;&gt; index = await lx.index.acreate_index(index_id=\"code_index\",\n...                                      description=\"Code embedding index\",\n...                                      index_fields=code_index_fields)\n</code></pre> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>async def acreate_index(\n    self,\n    index_id: str,\n    description: Optional[str] = None,\n    index_table_schema: Optional[dict[str, Any]] = None,\n    index_fields: Optional[dict[str, Any]] = None,\n) -&gt; Index:\n    \"\"\"Asynchronously create an index.\n\n    Args:\n        index_id (str): The ID of the index to create.\n        description (str, optional): A description of the index. Defaults to None.\n        index_table_schema (dict[str, Any]): The schema of the index table.\n            Defaults to None.\n        index_fields (dict[str, Any]): The index fields that are created in the\n            index table. These are typically the fields you want to populate using\n            transformers. Defaults to None.\n\n    Returns:\n        Index: The index.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; code_index_fields = {\n        ...     \"code\": {\"type\": \"text\"},\n        ...     \"code_embedding\": {\"type\": \"embedding\", \"extras\": {\"dims\": 384, \"model\": \"text.embeddings.minilm\"}},\n        ...     \"n_lines\": {\"type\": \"int\"},\n        ... }\n        &gt;&gt;&gt; index = await lx.index.acreate_index(index_id=\"code_index\",\n        ...                                      description=\"Code embedding index\",\n        ...                                      index_fields=code_index_fields)\n    \"\"\"\n    if index_table_schema is None:\n        index_table_schema = {}\n    if index_fields is None:\n        index_fields = {}\n    data = {\n        \"index_id\": index_id,\n        \"description\": description,\n        \"index_table_schema\": index_table_schema,\n        \"index_fields\": index_fields,\n    }\n    r = await self.aclient.post(\"/indexes\", json=data)\n    handle_response(r)\n    return Index(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.adelete_index","title":"<code>adelete_index(index_id, drop_table=False)</code>  <code>async</code>","text":"<p>Asynchronously delete an index.</p> <p>Parameters:</p> Name Type Description Default <code>index_id</code> <code>str</code> <p>The ID of the index to delete.</p> required <code>drop_table</code> <code>bool</code> <p>Whether to drop the index table from the database. Defaults to False.</p> <code>False</code> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>async def adelete_index(self, index_id: str, drop_table: bool = False) -&gt; dict:\n    \"\"\"Asynchronously delete an index.\n\n    Args:\n        index_id (str): The ID of the index to delete.\n        drop_table (bool, optional): Whether to drop the index table from the\n            database. Defaults to False.\n    \"\"\"\n    r = await self.aclient.delete(\n        f\"/indexes/{index_id}\", params={\"drop_table\": drop_table}\n    )\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.aget_index","title":"<code>aget_index(index_id)</code>  <code>async</code>","text":"<p>Asynchronously get an index.</p> <p>Parameters:</p> Name Type Description Default <code>index_id</code> <code>str</code> <p>The ID of the index to get.</p> required <p>Returns:</p> Name Type Description <code>Index</code> <code>Index</code> <p>The index.</p> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>async def aget_index(self, index_id: str) -&gt; Index:\n    \"\"\"Asynchronously get an index.\n\n    Args:\n        index_id (str): The ID of the index to get.\n\n    Returns:\n        Index: The index.\n    \"\"\"\n    r = await self.aclient.get(f\"/indexes/{index_id}\")\n    handle_response(r)\n    return Index(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.alist_indexes","title":"<code>alist_indexes()</code>  <code>async</code>","text":"<p>Asynchronously get a list of all indexes.</p> <p>Returns:</p> Type Description <code>list[Index]</code> <p>list[Index]: A list of all indexes.</p> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>async def alist_indexes(self) -&gt; list[Index]:\n    \"\"\"Asynchronously get a list of all indexes.\n\n    Returns:\n        list[Index]: A list of all indexes.\n    \"\"\"\n    r = await self.aclient.get(\"/indexes\")\n    handle_response(r)\n    return [Index(**index, client=self._lexy_client) for index in r.json()]\n</code></pre>"},{"location":"reference/lexy_py/indexes/#lexy_py.index.client.IndexClient.aupdate_index","title":"<code>aupdate_index(index_id, description=None, index_table_schema=None, index_fields=None)</code>  <code>async</code>","text":"<p>Asynchronously update an index.</p> <p>Parameters:</p> Name Type Description Default <code>index_id</code> <code>str</code> <p>The ID of the index to update.</p> required <code>description</code> <code>str</code> <p>The new description of the index.</p> <code>None</code> <code>index_table_schema</code> <code>dict[str, Any]</code> <p>The new schema of the index table.</p> <code>None</code> <code>index_fields</code> <code>dict[str, Any]</code> <p>The new value for index fields that are created in the index table.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Index</code> <code>Index</code> <p>The updated index.</p> Source code in <code>sdk-python/lexy_py/index/client.py</code> <pre><code>async def aupdate_index(\n    self,\n    index_id: str,\n    description: Optional[str] = None,\n    index_table_schema: Optional[dict[str, Any]] = None,\n    index_fields: Optional[dict[str, Any]] = None,\n) -&gt; Index:\n    \"\"\"Asynchronously update an index.\n\n    Args:\n        index_id (str): The ID of the index to update.\n        description (str, optional): The new description of the index.\n        index_table_schema (dict[str, Any], optional): The new schema of the index\n            table.\n        index_fields (dict[str, Any], optional): The new value for index fields\n            that are created in the index table.\n\n    Returns:\n        Index: The updated index.\n    \"\"\"\n    index = IndexUpdate(\n        description=description,\n        index_table_schema=index_table_schema,\n        index_fields=index_fields,\n    )\n    r = await self.aclient.patch(\n        f\"/indexes/{index_id}\", json=index.model_dump(exclude_none=True)\n    )\n    handle_response(r)\n    return Index(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/transformer/","title":"Documentation for <code>Transformer</code>","text":""},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.models.Transformer","title":"<code>lexy_py.transformer.models.Transformer</code>","text":"<p>             Bases: <code>TransformerModel</code></p> <p>Transformer model</p> Source code in <code>sdk-python/lexy_py/transformer/models.py</code> <pre><code>class Transformer(TransformerModel):\n    __doc__ = TransformerModel.__doc__\n    _client: Optional[\"LexyClient\"] = PrivateAttr(default=None)\n\n    def __init__(self, **data: Any):\n        super().__init__(**data)\n        self._client = data.pop(\"client\", None)\n\n    @property\n    def client(self) -&gt; \"LexyClient\":\n        if not self._client:\n            raise ValueError(\"API client has not been set.\")\n        return self._client\n\n    def transform_document(\n        self,\n        document: Document | dict,\n        transformer_params: dict = None,\n        content_only: bool = False,\n    ) -&gt; dict:\n        \"\"\"Synchronously transform a document.\n\n        Args:\n            document (Document | dict): The document to transform.\n            transformer_params (dict, optional): The transformer parameters. Defaults\n                to None.\n            content_only (bool, optional): Whether to submit only the document content\n                and not the document itself. Use this option when the transformer\n                doesn't accept Document objects as inputs. Defaults to False.\n\n        Returns:\n            dict: A dictionary containing the generated task ID and the result of the\n                transformer.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; minilm = lx.get_transformer('text.embeddings.minilm')\n            &gt;&gt;&gt; minilm.transform_document({'content': 'Good morning!'})\n            {'task_id': '449d9d79-4a57-4191-95d3-9c38955c8ced',\n             'result': [-0.03085244633257389, 0.028894789516925812, ...]}\n        \"\"\"\n        return self.client.transformer.transform_document(\n            transformer_id=self.transformer_id,\n            document=document,\n            transformer_params=transformer_params,\n            content_only=content_only,\n        )\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.models.Transformer.transform_document","title":"<code>transform_document(document, transformer_params=None, content_only=False)</code>","text":"<p>Synchronously transform a document.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document | dict</code> <p>The document to transform.</p> required <code>transformer_params</code> <code>dict</code> <p>The transformer parameters. Defaults to None.</p> <code>None</code> <code>content_only</code> <code>bool</code> <p>Whether to submit only the document content and not the document itself. Use this option when the transformer doesn't accept Document objects as inputs. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the generated task ID and the result of the transformer.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; minilm = lx.get_transformer('text.embeddings.minilm')\n&gt;&gt;&gt; minilm.transform_document({'content': 'Good morning!'})\n{'task_id': '449d9d79-4a57-4191-95d3-9c38955c8ced',\n 'result': [-0.03085244633257389, 0.028894789516925812, ...]}\n</code></pre> Source code in <code>sdk-python/lexy_py/transformer/models.py</code> <pre><code>def transform_document(\n    self,\n    document: Document | dict,\n    transformer_params: dict = None,\n    content_only: bool = False,\n) -&gt; dict:\n    \"\"\"Synchronously transform a document.\n\n    Args:\n        document (Document | dict): The document to transform.\n        transformer_params (dict, optional): The transformer parameters. Defaults\n            to None.\n        content_only (bool, optional): Whether to submit only the document content\n            and not the document itself. Use this option when the transformer\n            doesn't accept Document objects as inputs. Defaults to False.\n\n    Returns:\n        dict: A dictionary containing the generated task ID and the result of the\n            transformer.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; minilm = lx.get_transformer('text.embeddings.minilm')\n        &gt;&gt;&gt; minilm.transform_document({'content': 'Good morning!'})\n        {'task_id': '449d9d79-4a57-4191-95d3-9c38955c8ced',\n         'result': [-0.03085244633257389, 0.028894789516925812, ...]}\n    \"\"\"\n    return self.client.transformer.transform_document(\n        transformer_id=self.transformer_id,\n        document=document,\n        transformer_params=transformer_params,\n        content_only=content_only,\n    )\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.models.TransformerModel","title":"<code>lexy_py.transformer.models.TransformerModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Transformer model</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> required <code>path</code> <code>str | None</code> <code>None</code> <code>description</code> <code>str | None</code> <code>None</code> <code>created_at</code> <code>datetime | None</code> <code>None</code> <code>updated_at</code> <code>datetime | None</code> <code>None</code> Source code in <code>sdk-python/lexy_py/transformer/models.py</code> <pre><code>class TransformerModel(BaseModel):\n    \"\"\"Transformer model\"\"\"\n\n    transformer_id: str = Field(\n        ..., min_length=1, max_length=255, pattern=r\"^[a-zA-Z][a-zA-Z0-9_.-]+$\"\n    )\n    path: Optional[str] = Field(\n        default=None, min_length=1, max_length=255, pattern=r\"^[a-zA-Z][a-zA-Z0-9_.]+$\"\n    )\n    description: Optional[str] = None\n    created_at: Optional[datetime] = None\n    updated_at: Optional[datetime] = None\n\n    def __repr__(self):\n        return (\n            f\"&lt;Transformer('{self.transformer_id}', description='{self.description}')&gt;\"\n        )\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient","title":"<code>lexy_py.transformer.client.TransformerClient</code>","text":"<p>This class is used to interact with the Lexy Transformer API.</p> <p>Attributes:</p> Name Type Description <code>aclient</code> <code>AsyncClient</code> <p>Asynchronous API client.</p> <code>client</code> <code>Client</code> <p>Synchronous API client.</p> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>class TransformerClient:\n    \"\"\"\n    This class is used to interact with the Lexy Transformer API.\n\n    Attributes:\n        aclient (httpx.AsyncClient): Asynchronous API client.\n        client (httpx.Client): Synchronous API client.\n    \"\"\"\n\n    def __init__(self, lexy_client: \"LexyClient\") -&gt; None:\n        self._lexy_client = lexy_client\n\n    @property\n    def aclient(self) -&gt; httpx.AsyncClient:\n        return self._lexy_client.aclient\n\n    @property\n    def client(self) -&gt; httpx.Client:\n        return self._lexy_client.client\n\n    def list_transformers(self) -&gt; list[Transformer]:\n        \"\"\"Synchronously get a list of all transformers.\n\n        Returns:\n            list[Transformer]: A list of all transformers.\n        \"\"\"\n        r = self.client.get(\"/transformers\")\n        handle_response(r)\n        return [\n            Transformer(**transformer, client=self._lexy_client)\n            for transformer in r.json()\n        ]\n\n    async def alist_transformers(self) -&gt; list[Transformer]:\n        \"\"\"Asynchronously get a list of all transformers.\n\n        Returns:\n            list[Transformer]: A list of all transformers.\n        \"\"\"\n        r = await self.aclient.get(\"/transformers\")\n        handle_response(r)\n        return [\n            Transformer(**transformer, client=self._lexy_client)\n            for transformer in r.json()\n        ]\n\n    def get_transformer(self, transformer_id: str) -&gt; Transformer:\n        \"\"\"Synchronously get a transformer.\n\n        Args:\n            transformer_id (str): The ID of the transformer to get.\n\n        Returns:\n            Transformer: The transformer.\n        \"\"\"\n        r = self.client.get(f\"/transformers/{transformer_id}\")\n        handle_response(r)\n        return Transformer(**r.json(), client=self._lexy_client)\n\n    async def aget_transformer(self, transformer_id: str) -&gt; Transformer:\n        \"\"\"Asynchronously get a transformer.\n\n        Args:\n            transformer_id (str): The ID of the transformer to get.\n\n        Returns:\n            Transformer: The transformer.\n        \"\"\"\n        r = await self.aclient.get(f\"/transformers/{transformer_id}\")\n        handle_response(r)\n        return Transformer(**r.json(), client=self._lexy_client)\n\n    def create_transformer(\n        self,\n        transformer_id: str,\n        *,\n        path: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Transformer:\n        \"\"\"Synchronously create a transformer.\n\n        Args:\n            transformer_id (str): The ID of the transformer to create.\n            path (str, optional): The path of the transformer to create.\n            description (str, optional): The description of the transformer to create.\n\n        Returns:\n            Transformer: The created transformer.\n        \"\"\"\n        transformer = Transformer(\n            transformer_id=transformer_id, path=path, description=description\n        )\n        r = self.client.post(\"/transformers\", json=transformer.model_dump())\n        handle_response(r)\n        return Transformer(**r.json(), client=self._lexy_client)\n\n    async def acreate_transformer(\n        self,\n        transformer_id: str,\n        *,\n        path: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Transformer:\n        \"\"\"Asynchronously create a transformer.\n\n        Args:\n            transformer_id (str): The ID of the transformer to create.\n            path (str, optional): The path of the transformer to create.\n            description (str, optional): The description of the transformer to create.\n\n        Returns:\n            Transformer: The created transformer.\n        \"\"\"\n        transformer = Transformer(\n            transformer_id=transformer_id, path=path, description=description\n        )\n        r = await self.aclient.post(\"/transformers\", json=transformer.model_dump())\n        handle_response(r)\n        return Transformer(**r.json(), client=self._lexy_client)\n\n    def update_transformer(\n        self,\n        transformer_id: str,\n        *,\n        path: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Transformer:\n        \"\"\"Synchronously update a transformer.\n\n        Args:\n            transformer_id (str): The ID of the transformer to update.\n            path (str, optional): The updated path of the transformer.\n            description (str, optional): The updated description of the transformer.\n\n        Returns:\n            Transformer: The updated transformer.\n        \"\"\"\n        transformer = TransformerUpdate(path=path, description=description)\n        r = self.client.patch(\n            f\"/transformers/{transformer_id}\",\n            json=transformer.model_dump(exclude_none=True),\n        )\n        handle_response(r)\n        return Transformer(**r.json(), client=self._lexy_client)\n\n    async def aupdate_transformer(\n        self,\n        transformer_id: str,\n        *,\n        path: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Transformer:\n        \"\"\"Asynchronously update a transformer.\n\n        Args:\n            transformer_id (str): The ID of the transformer to update.\n            path (str, optional): The updated path of the transformer.\n            description (str, optional): The updated description of the transformer.\n\n        Returns:\n            Transformer: The updated transformer.\n        \"\"\"\n        transformer = TransformerUpdate(path=path, description=description)\n        r = await self.aclient.patch(\n            f\"/transformers/{transformer_id}\",\n            json=transformer.model_dump(exclude_none=True),\n        )\n        handle_response(r)\n        return Transformer(**r.json(), client=self._lexy_client)\n\n    def delete_transformer(self, transformer_id: str) -&gt; dict:\n        \"\"\"Synchronously delete a transformer.\n\n        Args:\n            transformer_id (str): The ID of the transformer to delete.\n        \"\"\"\n        r = self.client.delete(f\"/transformers/{transformer_id}\")\n        handle_response(r)\n        return r.json()\n\n    async def adelete_transformer(self, transformer_id: str) -&gt; dict:\n        \"\"\"Asynchronously delete a transformer.\n\n        Args:\n            transformer_id (str): The ID of the transformer to delete.\n        \"\"\"\n        r = await self.aclient.delete(f\"/transformers/{transformer_id}\")\n        handle_response(r)\n        return r.json()\n\n    def transform_document(\n        self,\n        transformer_id: str,\n        document: Document | dict,\n        transformer_params: dict = None,\n        content_only: bool = False,\n    ) -&gt; dict:\n        \"\"\"Synchronously transform a document.\n\n        Args:\n            transformer_id (str): The ID of the transformer to use.\n            document (Document | dict): The document to transform.\n            transformer_params (dict, optional): The transformer parameters. Defaults\n                to None.\n            content_only (bool, optional): Whether to submit only the document content\n                and not the document itself. Use this option when the transformer\n                doesn't accept Document objects as inputs. Defaults to False.\n\n        Returns:\n            dict: A dictionary containing the generated task ID and the result of the\n                transformer.\n\n        Examples:\n            &gt;&gt;&gt; from lexy_py import LexyClient\n            &gt;&gt;&gt; lx = LexyClient()\n            &gt;&gt;&gt; lx.transformer.transform_document(\"text.counter.word_counter\", {\"content\": \"Hello world!\"})\n            {'task_id': '65ecd2f7-bac4-4747-9e65-a6d21a72f585', 'result': [2, 'world!']}\n        \"\"\"\n        if isinstance(document, dict):\n            document = Document(**document)\n        data = {\"document\": document.model_dump(mode=\"json\")}\n        if transformer_params:\n            data[\"transformer_params\"] = transformer_params\n        if content_only:\n            data[\"content_only\"] = content_only\n        r = self.client.post(f\"/transformers/{transformer_id}\", json=data)\n        handle_response(r)\n        return r.json()\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.create_transformer","title":"<code>create_transformer(transformer_id, *, path=None, description=None)</code>","text":"<p>Synchronously create a transformer.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> <p>The ID of the transformer to create.</p> required <code>path</code> <code>str</code> <p>The path of the transformer to create.</p> <code>None</code> <code>description</code> <code>str</code> <p>The description of the transformer to create.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Transformer</code> <code>Transformer</code> <p>The created transformer.</p> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>def create_transformer(\n    self,\n    transformer_id: str,\n    *,\n    path: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Transformer:\n    \"\"\"Synchronously create a transformer.\n\n    Args:\n        transformer_id (str): The ID of the transformer to create.\n        path (str, optional): The path of the transformer to create.\n        description (str, optional): The description of the transformer to create.\n\n    Returns:\n        Transformer: The created transformer.\n    \"\"\"\n    transformer = Transformer(\n        transformer_id=transformer_id, path=path, description=description\n    )\n    r = self.client.post(\"/transformers\", json=transformer.model_dump())\n    handle_response(r)\n    return Transformer(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.delete_transformer","title":"<code>delete_transformer(transformer_id)</code>","text":"<p>Synchronously delete a transformer.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> <p>The ID of the transformer to delete.</p> required Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>def delete_transformer(self, transformer_id: str) -&gt; dict:\n    \"\"\"Synchronously delete a transformer.\n\n    Args:\n        transformer_id (str): The ID of the transformer to delete.\n    \"\"\"\n    r = self.client.delete(f\"/transformers/{transformer_id}\")\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.get_transformer","title":"<code>get_transformer(transformer_id)</code>","text":"<p>Synchronously get a transformer.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> <p>The ID of the transformer to get.</p> required <p>Returns:</p> Name Type Description <code>Transformer</code> <code>Transformer</code> <p>The transformer.</p> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>def get_transformer(self, transformer_id: str) -&gt; Transformer:\n    \"\"\"Synchronously get a transformer.\n\n    Args:\n        transformer_id (str): The ID of the transformer to get.\n\n    Returns:\n        Transformer: The transformer.\n    \"\"\"\n    r = self.client.get(f\"/transformers/{transformer_id}\")\n    handle_response(r)\n    return Transformer(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.list_transformers","title":"<code>list_transformers()</code>","text":"<p>Synchronously get a list of all transformers.</p> <p>Returns:</p> Type Description <code>list[Transformer]</code> <p>list[Transformer]: A list of all transformers.</p> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>def list_transformers(self) -&gt; list[Transformer]:\n    \"\"\"Synchronously get a list of all transformers.\n\n    Returns:\n        list[Transformer]: A list of all transformers.\n    \"\"\"\n    r = self.client.get(\"/transformers\")\n    handle_response(r)\n    return [\n        Transformer(**transformer, client=self._lexy_client)\n        for transformer in r.json()\n    ]\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.transform_document","title":"<code>transform_document(transformer_id, document, transformer_params=None, content_only=False)</code>","text":"<p>Synchronously transform a document.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> <p>The ID of the transformer to use.</p> required <code>document</code> <code>Document | dict</code> <p>The document to transform.</p> required <code>transformer_params</code> <code>dict</code> <p>The transformer parameters. Defaults to None.</p> <code>None</code> <code>content_only</code> <code>bool</code> <p>Whether to submit only the document content and not the document itself. Use this option when the transformer doesn't accept Document objects as inputs. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the generated task ID and the result of the transformer.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from lexy_py import LexyClient\n&gt;&gt;&gt; lx = LexyClient()\n&gt;&gt;&gt; lx.transformer.transform_document(\"text.counter.word_counter\", {\"content\": \"Hello world!\"})\n{'task_id': '65ecd2f7-bac4-4747-9e65-a6d21a72f585', 'result': [2, 'world!']}\n</code></pre> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>def transform_document(\n    self,\n    transformer_id: str,\n    document: Document | dict,\n    transformer_params: dict = None,\n    content_only: bool = False,\n) -&gt; dict:\n    \"\"\"Synchronously transform a document.\n\n    Args:\n        transformer_id (str): The ID of the transformer to use.\n        document (Document | dict): The document to transform.\n        transformer_params (dict, optional): The transformer parameters. Defaults\n            to None.\n        content_only (bool, optional): Whether to submit only the document content\n            and not the document itself. Use this option when the transformer\n            doesn't accept Document objects as inputs. Defaults to False.\n\n    Returns:\n        dict: A dictionary containing the generated task ID and the result of the\n            transformer.\n\n    Examples:\n        &gt;&gt;&gt; from lexy_py import LexyClient\n        &gt;&gt;&gt; lx = LexyClient()\n        &gt;&gt;&gt; lx.transformer.transform_document(\"text.counter.word_counter\", {\"content\": \"Hello world!\"})\n        {'task_id': '65ecd2f7-bac4-4747-9e65-a6d21a72f585', 'result': [2, 'world!']}\n    \"\"\"\n    if isinstance(document, dict):\n        document = Document(**document)\n    data = {\"document\": document.model_dump(mode=\"json\")}\n    if transformer_params:\n        data[\"transformer_params\"] = transformer_params\n    if content_only:\n        data[\"content_only\"] = content_only\n    r = self.client.post(f\"/transformers/{transformer_id}\", json=data)\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.update_transformer","title":"<code>update_transformer(transformer_id, *, path=None, description=None)</code>","text":"<p>Synchronously update a transformer.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> <p>The ID of the transformer to update.</p> required <code>path</code> <code>str</code> <p>The updated path of the transformer.</p> <code>None</code> <code>description</code> <code>str</code> <p>The updated description of the transformer.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Transformer</code> <code>Transformer</code> <p>The updated transformer.</p> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>def update_transformer(\n    self,\n    transformer_id: str,\n    *,\n    path: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Transformer:\n    \"\"\"Synchronously update a transformer.\n\n    Args:\n        transformer_id (str): The ID of the transformer to update.\n        path (str, optional): The updated path of the transformer.\n        description (str, optional): The updated description of the transformer.\n\n    Returns:\n        Transformer: The updated transformer.\n    \"\"\"\n    transformer = TransformerUpdate(path=path, description=description)\n    r = self.client.patch(\n        f\"/transformers/{transformer_id}\",\n        json=transformer.model_dump(exclude_none=True),\n    )\n    handle_response(r)\n    return Transformer(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.acreate_transformer","title":"<code>acreate_transformer(transformer_id, *, path=None, description=None)</code>  <code>async</code>","text":"<p>Asynchronously create a transformer.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> <p>The ID of the transformer to create.</p> required <code>path</code> <code>str</code> <p>The path of the transformer to create.</p> <code>None</code> <code>description</code> <code>str</code> <p>The description of the transformer to create.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Transformer</code> <code>Transformer</code> <p>The created transformer.</p> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>async def acreate_transformer(\n    self,\n    transformer_id: str,\n    *,\n    path: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Transformer:\n    \"\"\"Asynchronously create a transformer.\n\n    Args:\n        transformer_id (str): The ID of the transformer to create.\n        path (str, optional): The path of the transformer to create.\n        description (str, optional): The description of the transformer to create.\n\n    Returns:\n        Transformer: The created transformer.\n    \"\"\"\n    transformer = Transformer(\n        transformer_id=transformer_id, path=path, description=description\n    )\n    r = await self.aclient.post(\"/transformers\", json=transformer.model_dump())\n    handle_response(r)\n    return Transformer(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.adelete_transformer","title":"<code>adelete_transformer(transformer_id)</code>  <code>async</code>","text":"<p>Asynchronously delete a transformer.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> <p>The ID of the transformer to delete.</p> required Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>async def adelete_transformer(self, transformer_id: str) -&gt; dict:\n    \"\"\"Asynchronously delete a transformer.\n\n    Args:\n        transformer_id (str): The ID of the transformer to delete.\n    \"\"\"\n    r = await self.aclient.delete(f\"/transformers/{transformer_id}\")\n    handle_response(r)\n    return r.json()\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.aget_transformer","title":"<code>aget_transformer(transformer_id)</code>  <code>async</code>","text":"<p>Asynchronously get a transformer.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> <p>The ID of the transformer to get.</p> required <p>Returns:</p> Name Type Description <code>Transformer</code> <code>Transformer</code> <p>The transformer.</p> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>async def aget_transformer(self, transformer_id: str) -&gt; Transformer:\n    \"\"\"Asynchronously get a transformer.\n\n    Args:\n        transformer_id (str): The ID of the transformer to get.\n\n    Returns:\n        Transformer: The transformer.\n    \"\"\"\n    r = await self.aclient.get(f\"/transformers/{transformer_id}\")\n    handle_response(r)\n    return Transformer(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.alist_transformers","title":"<code>alist_transformers()</code>  <code>async</code>","text":"<p>Asynchronously get a list of all transformers.</p> <p>Returns:</p> Type Description <code>list[Transformer]</code> <p>list[Transformer]: A list of all transformers.</p> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>async def alist_transformers(self) -&gt; list[Transformer]:\n    \"\"\"Asynchronously get a list of all transformers.\n\n    Returns:\n        list[Transformer]: A list of all transformers.\n    \"\"\"\n    r = await self.aclient.get(\"/transformers\")\n    handle_response(r)\n    return [\n        Transformer(**transformer, client=self._lexy_client)\n        for transformer in r.json()\n    ]\n</code></pre>"},{"location":"reference/lexy_py/transformer/#lexy_py.transformer.client.TransformerClient.aupdate_transformer","title":"<code>aupdate_transformer(transformer_id, *, path=None, description=None)</code>  <code>async</code>","text":"<p>Asynchronously update a transformer.</p> <p>Parameters:</p> Name Type Description Default <code>transformer_id</code> <code>str</code> <p>The ID of the transformer to update.</p> required <code>path</code> <code>str</code> <p>The updated path of the transformer.</p> <code>None</code> <code>description</code> <code>str</code> <p>The updated description of the transformer.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Transformer</code> <code>Transformer</code> <p>The updated transformer.</p> Source code in <code>sdk-python/lexy_py/transformer/client.py</code> <pre><code>async def aupdate_transformer(\n    self,\n    transformer_id: str,\n    *,\n    path: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Transformer:\n    \"\"\"Asynchronously update a transformer.\n\n    Args:\n        transformer_id (str): The ID of the transformer to update.\n        path (str, optional): The updated path of the transformer.\n        description (str, optional): The updated description of the transformer.\n\n    Returns:\n        Transformer: The updated transformer.\n    \"\"\"\n    transformer = TransformerUpdate(path=path, description=description)\n    r = await self.aclient.patch(\n        f\"/transformers/{transformer_id}\",\n        json=transformer.model_dump(exclude_none=True),\n    )\n    handle_response(r)\n    return Transformer(**r.json(), client=self._lexy_client)\n</code></pre>"},{"location":"reference/rest-api/","title":"REST API","text":"<p>Lexy offers a RESTful API. The endpoints below allow you to create, read, update, and delete resources on the Lexy Server. There is also a Python SDK available for interacting with the server.</p> <p></p>"},{"location":"tutorials/","title":"Getting started with Lexy","text":""},{"location":"tutorials/#first-steps","title":"First steps","text":"<p>Let's get started by instantiating the Lexy client. By default, this will connect to the Lexy server running at <code>http://localhost:9900</code>. You can visit the OpenAPI documentation for the server at <code>http://localhost:9900/docs</code>.</p> <pre><code>from lexy_py import LexyClient\n\nlx = LexyClient()\n</code></pre> <p>We can get more information about the Lexy server by calling the <code>info</code> method. Here we see existing Collections, Indexes, Transformers, and Bindings.</p> <pre><code>lx.info()\n</code></pre> <pre><code>Lexy server &lt;http://localhost:9900/api&gt;\n\n2 Collections\n    - &lt;Collection('default', description='Default collection')&gt;\n    - &lt;Collection('code', description='Github code repos')&gt;\n1 Indexes\n    - &lt;Index('default_text_embeddings', description='Text embeddings for default collection')&gt;\n6 Transformers\n    - &lt;Transformer('image.embeddings.clip', description='Embed images using 'openai/clip-vit-base-patch32'.')&gt;,\n    - &lt;Transformer('text.embeddings.clip', description='Embed text using 'openai/clip-vit-base-patch32'.')&gt;,\n    - &lt;Transformer('text.embeddings.minilm', description='Text embeddings using \"sentence-transformers/all-MiniLM-L6-v2\"')&gt;,\n    - &lt;...additional transformers...&gt;\n1 Bindings\n    - &lt;Binding(id=1, status=ON, collection='default', transformer='text.embeddings.minilm', index='default_text_embeddings')&gt;\n</code></pre> <p>Let's add some documents to our \"default\" collection. We can add them using the <code>LexyClient.add_documents</code> method.</p> <pre><code>lx.add_documents([\n    {\"content\": \"This is my first document! It's great!\"},\n    {\"content\": \"Starlink is a satellite internet constellation operated by American aerospace company SpaceX, providing coverage to over 60 countries.\"},\n    {\"content\": \"A latent space is an embedding of a set of items within a manifold in which items resembling each other are positioned closer to one another.\"}\n])\n</code></pre> <pre><code>[&lt;Document(\"This is my first document! It's great!\")&gt;,\n &lt;Document(\"Starlink is a satellite internet constellation operated by American aerospace company SpaceX,...\")&gt;,\n &lt;Document(\"A latent space is an embedding of a set of items within a manifold in which items resembling each...\")&gt;]\n</code></pre> <p>Documents that are added to the \"default\" collection are automatically embedded, and the embeddings are stored in the index \"default_text_embeddings\".</p> <pre><code>flowchart LR\n    collection[\"Collection\n\n    &amp;quot;default&amp;quot;\"]\n    --&gt;\n    transformer[\"Transformer\n\n    &amp;quot;text.embeddings.minilm&amp;quot;\"]\n    --&gt;\n    index[\"Index\n\n    &amp;quot;default_text_embeddings&amp;quot;\"];</code></pre> <p>We can query the default index for \"what is deep learning\" and see our documents ranked by cosine similarity.</p> <pre><code>lx.query_index('what is deep learning')\n</code></pre> <pre><code>[{'document_id': '28dee402-31aa-4622-89e9-ce9ac06a4cf8',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': '56c2e116-13af-4db6-ac27-68cb44f3077c',\n  'content': 'A latent space is an embedding of a set of items within a manifold in which items resembling each other are positioned closer to one another.',\n  'distance': 1.2856687307357788},\n {'document_id': '01e1f7ff-a890-4f6a-aeac-a0f99bdf9e77',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': '5544c784-5e7c-4b34-bd73-dc4cbd139af6',\n  'content': \"This is my first document! It's great!\",\n  'distance': 1.3882379531860352},\n {'document_id': '449cc363-dc2b-45cf-b47e-6465af505401',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': '9b57f1e0-de4c-4b2b-95b9-0d77af31fe2c',\n  'content': 'Starlink is a satellite internet constellation operated by American aerospace company SpaceX, providing coverage to over 60 countries.',\n  'distance': 1.3894593715667725,}]\n</code></pre>"},{"location":"tutorials/#example-famous-biographies","title":"Example: Famous biographies","text":"<p>Let's go through a longer example to see how Collections, Documents, Indexes, Bindings, and Transformers interact with one another. We'll use Lexy to create and query embeddings for a new collection of documents.</p>"},{"location":"tutorials/#collections","title":"Collections","text":"<p>We can see that there are currently two collections, \"default\" and \"code\".</p> <pre><code>lx.collections\n</code></pre> <pre><code>[&lt;Collection('default', description='Default collection')&gt;,\n &lt;Collection('code', description='Github code repos')&gt;]\n</code></pre> <p>Let's create a new \"bios\" collection for famous biographies.</p> <pre><code>bios = lx.create_collection('bios', description='Famous biographies')\nbios\n</code></pre> <pre><code>&lt;Collection('bios', description='Famous biographies')&gt;\n</code></pre>"},{"location":"tutorials/#documents","title":"Documents","text":"<p>We can use the <code>Collection.list_documents</code> method to see that our new collection is empty.</p> <pre><code>bios.list_documents()\n</code></pre> <pre><code>[]\n</code></pre> <p>Let's add a few documents to our collection.</p> <pre><code>bios.add_documents([\n    {\"content\": \"Stephen Curry is an American professional basketball player for the Golden State Warriors.\"},\n    {\"content\": \"Dwayne 'The Rock' Johnson is a well-known actor, former professional wrestler, and businessman.\"},\n    {\"content\": \"Taylor Swift is a singer known for her songwriting, musical versatility, and artistic reinventions.\"}\n])\n</code></pre> <pre><code>[&lt;Document(\"Stephen Curry is an American professional basketball player for the Golden State Warriors.\")&gt;,\n &lt;Document(\"Dwayne 'The Rock' Johnson is a well-known actor, former professional wrestler, and businessman.\")&gt;,\n &lt;Document(\"Taylor Swift is a singer known for her songwriting, musical versatility, and artistic reinventions.\")&gt;]\n</code></pre>"},{"location":"tutorials/#transformers","title":"Transformers","text":"<p>Now we want to create embeddings for the documents in our new collection. We'll use a <code>Transformer</code> to generate embeddings for our documents. We can use the <code>LexyClient.transformers</code> property to see a list of available transformers.</p> <pre><code># list of available transformers\nlx.transformers\n</code></pre> <pre><code>[&lt;Transformer('image.embeddings.clip', description='Embed images using 'openai/clip-vit-base-patch32'.')&gt;,\n &lt;Transformer('text.embeddings.clip', description='Embed text using 'openai/clip-vit-base-patch32'.')&gt;,\n &lt;Transformer('text.embeddings.minilm', description='Text embeddings using \"sentence-transformers/all-MiniLM-L6-v2\"')&gt;,\n &lt;Transformer('text.embeddings.openai-3-large', description='Text embeddings using OpenAI's \"text-embedding-3-large\" model')&gt;,\n &lt;Transformer('text.embeddings.openai-3-small', description='Text embeddings using OpenAI's \"text-embedding-3-small\" model')&gt;,\n &lt;Transformer('text.embeddings.openai-ada-002', description='OpenAI text embeddings using model text-embedding-ada-002')&gt;]\n</code></pre> <p>For our example, we'll use the \"text.embeddings.minilm\" transformer, which uses the MiniLM sentence transformer model to generate embeddings for text.</p>"},{"location":"tutorials/#indexes","title":"Indexes","text":"<p>Before we can bind this transformer to our collection, we need to create an <code>Index</code> for storing the resulting embeddings.</p> <p>Let's create a new index called \"bios_index\" with embeddings for our new collection. Our index will have a single field called <code>bio_embedding</code> that will store the embeddings output from the MiniLM sentence transformer.</p> <pre><code># define index fields\nindex_fields = {\n    \"bio_embedding\": {\n        \"type\": \"embedding\", \"extras\": {\"dims\": 384, \"model\": \"text.embeddings.minilm\"}\n    }\n}\n\n# create index\nindex = lx.create_index(\n    index_id='bios_index',\n    description='Biography embeddings',\n    index_fields=index_fields\n)\nindex\n</code></pre> <pre><code>&lt;Index('bios_index', description='Biography embeddings')&gt;\n</code></pre>"},{"location":"tutorials/#bindings","title":"Bindings","text":"<p>Now let's create a <code>Binding</code>. Our binding will: 1) Feed the documents in our \"bios\" collection into the \"text.embeddings.minilm\" transformer, then 2) Insert the resulting output in our newly created index, \"bios_index\". </p> <pre><code>flowchart LR\n    collection[\"Collection\n\n    &amp;quot;bios&amp;quot;\"]\n    --&gt;\n    transformer[\"Transformer\n\n    &amp;quot;text.embeddings.minilm&amp;quot;\"]\n    --&gt;\n    index[\"Index\n\n    &amp;quot;bios_index&amp;quot;\"];</code></pre> <pre><code>binding = lx.create_binding(\n    collection_name='bios',\n    transformer_id='text.embeddings.minilm',\n    index_id='bios_index'\n)\nbinding\n</code></pre> <pre><code>&lt;Binding(id=2, status=ON, collection='bios', transformer='text.embeddings.minilm', index='bios_index')&gt;\n</code></pre> <p>We can now query our index for \"famous artists\" and see the results ranked by cosine similarity.</p> <pre><code>index.query(query_text='famous artists', query_field='bio_embedding', k=3)\n</code></pre> <pre><code>[{'document_id': 'c1090c0f-5fb4-4e8b-af47-d3fecb1d3e11',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': '17ea9419-790f-4143-94c9-1c43a25a13e2',\n  'content': 'Taylor Swift is a singer known for her songwriting, musical versatility, and artistic reinventions.',\n  'distance': 1.1270135641098022},\n {'document_id': 'b0a5e701-749d-4361-a941-b8d6ffcbfe92',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': 'dc840614-43fc-48bc-b4a9-fedca1f5950d',\n  'content': \"Dwayne 'The Rock' Johnson is a well-known actor, former professional wrestler, and businessman.\",\n  'distance': 1.2409147024154663},\n {'document_id': '68b0bb68-fee4-4631-a5db-874a7af32b46',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': '5b44fa50-0b08-4797-84ca-af47c2f05dff',\n  'content': 'Stephen Curry is an American professional basketball player for the Golden State Warriors.',\n  'distance': 1.3264542818069458}]\n</code></pre> <p>Because our binding has status set to \"<code>ON</code>\", any new documents added to our collection will automatically be processed by our transformer and inserted into our index as embeddings.</p> <p>Let's add another document.</p> <pre><code>bios.add_documents([\n    {\"content\": \"Beyonc\u00e9 is a singer and songwriter recognized for her boundary-pushing artistry, vocals, and performances.\"}\n])\n</code></pre> <pre><code>[&lt;Document(\"Beyonc\u00e9 is a singer and songwriter recognized for her boundary-pushing artistry, vocals, and...\")&gt;]\n</code></pre> <p>Now let's run the same query again for \"famous artists\". We can see the results have been updated and include our new document.</p> <pre><code>index.query(query_text='famous artists', query_field='bio_embedding', k=3)\n</code></pre> <pre><code>[{'document_id': 'c1090c0f-5fb4-4e8b-af47-d3fecb1d3e11',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': '17ea9419-790f-4143-94c9-1c43a25a13e2',\n  'content': 'Taylor Swift is a singer known for her songwriting, musical versatility, and artistic reinventions.',\n  'distance': 1.1270135641098022},\n {'document_id': 'c7f51ec0-9f88-4fd7-a176-846cc6db1736',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': 'd55753d8-33cb-4a11-9a6f-c3c4a5fe2751',\n  'content': 'Beyonc\u00e9 is a singer and songwriter recognized for her boundary-pushing artistry, vocals, and performances.',\n  'distance': 1.1645721197128296},\n {'document_id': 'b0a5e701-749d-4361-a941-b8d6ffcbfe92',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': 'dc840614-43fc-48bc-b4a9-fedca1f5950d',\n  'content': \"Dwayne 'The Rock' Johnson is a well-known actor, former professional wrestler, and businessman.\",\n  'distance': 1.2409147024154663}]\n</code></pre>"},{"location":"tutorials/#next-steps","title":"Next steps","text":"<p>Check out the following tutorials to learn more about Lexy.</p> <ul> <li>Retrieval Augmented Generation (RAG) for a basic implementation of RAG using Lexy.</li> <li>Multimodal image search for how to use Lexy to build a multimodal search engine.</li> <li>Custom transformers for using your own functions as transformers.</li> <li>Document filters shows how to build pipelines for different types of documents.</li> <li>Structured data extraction for how to extract structured data from documents.</li> </ul>"},{"location":"tutorials/basic-rag/","title":"Retrieval Augmented Generation (RAG) with Lexy","text":""},{"location":"tutorials/basic-rag/#introduction","title":"Introduction","text":"<p>Let's go through a basic implementation of Retrieval-Augmented Generation (RAG) using Lexy. RAG describes the process of using a retriever to find relevant documents to include as context in the prompt for a language model.</p> <p>In this example, we'll use Lexy to store and retrieve documents describing characters from the TV show House of the Dragon. We'll then use those documents to construct a prompt that GPT-4 can use to answer questions about the characters.</p> <p>Notebook available</p> <p>You can find the complete code for this example in the Lexy GitHub repository. Follow along with this tutorial using the notebook <code>examples/basic_rag.ipynb</code>.</p> <p>This tutorial is a simplified introduction to RAG, and not a real-world application. This is done intentionally to teach the basic concept of RAG and how it is implemented. We'll point out some of these simplifications as we go along, and discuss them in more detail in the section Real-world considerations. We'll also provide links to additional tutorials which cover the complexities typically encountered in real-world RAG applications.</p>"},{"location":"tutorials/basic-rag/#openai-api-key","title":"OpenAI API Key","text":"<p>This example requires an OpenAI API key in order to (1) generate embeddings and (2) interact with GPT-4. Although this example uses OpenAI, you can use Lexy with any language model and any embedding model, including free, open-source models such as <code>SentenceTransformer</code>.</p> <p>You can add your API key as an environment variable using the <code>.env</code> file in the root directory of the Lexy repository. See How do I add a new environment variable on the FAQ page for more details.</p> .env<pre><code>OPENAI_API_KEY=your_secret_api_key\n</code></pre> <p>Remember to rebuild your containers after adding the environment variable (otherwise your container won't see the newly added variable). Simply run the following on the command line (ensure you're at the root directory for the Lexy repo):</p> <pre><code>make update-dev-containers\n</code></pre> <p>Then run the following in your notebook to load the environment variables.</p> <pre><code>import os\nfrom dotenv import load_dotenv\n\n# load environment variables, including OPENAI_API_KEY\nload_dotenv()\n\n# alternatively, you can set the environment variable directly\nif \"OPENAI_API_KEY\" not in os.environ:\n    os.environ[\"OPENAI_API_KEY\"] = \"your_secret_api_key\"\n</code></pre>"},{"location":"tutorials/basic-rag/#sample-data","title":"Sample data","text":"<p>Our data is in the <code>sample_data/documents</code> directory of the Lexy repo. Let's import it and take a look at the first few lines.</p> <pre><code>with open(\"../sample_data/documents/hotd.txt\") as f:\n    lines = f.read().splitlines()\n\nlines[:3]\n</code></pre> <pre><code>['Viserys I Targaryen is the fifth king of the Targaryen dynasty to rule the Seven Kingdoms. He is the father of Rhaenyra Targaryen and Aegon II Targaryen. His mount is the dragon Balerion.',\n 'Rhaenyra Targaryen is the eldest child of King Viserys I Targaryen and is considered the heir to the Iron Throne. She is a dragonrider whose mount is Syrax.',\n 'Aegon II Targaryen is the second-born child of Viserys I Targaryen and Alicent Hightower. He is a claimant to the Iron Throne and a dragonrider whose mount is Sunfyre.']\n</code></pre>"},{"location":"tutorials/basic-rag/#add-documents-to-lexy","title":"Add documents to Lexy","text":"<p>Tip</p> <p>This tutorial assumes you have a basic understanding of Lexy and its core concepts. If you're new to Lexy, we recommend you start with the Getting Started tutorial to learn more about Collections, Documents, Transformers, Indexes, and Bindings.</p> <p>Let's instantiate a Lexy client and create a new collection for our documents.</p> <pre><code>from lexy_py import LexyClient\n\nlx = LexyClient()\n</code></pre> <pre><code># create a new collection\ncollection = lx.create_collection(\n    collection_name=\"house_of_the_dragon\",\n    description=\"House of the Dragon characters\"\n)\ncollection\n</code></pre> <pre><code>&lt;Collection('house_of_the_dragon', description='House of the Dragon characters')&gt;\n</code></pre> <p>We can add documents to our new collection using the <code>Collection.add_documents</code> method.</p> <pre><code>collection.add_documents([\n    {\"content\": line} for line in lines\n])\n</code></pre> <pre><code>[&lt;Document(\"Viserys I Targaryen is the fifth king of the Targaryen dynasty to rule the Seven Kingdoms. He is...\")&gt;,\n &lt;Document(\"Rhaenyra Targaryen is the eldest child of King Viserys I Targaryen and is considered the heir to...\")&gt;,\n &lt;Document(\"Aegon II Targaryen is the second-born child of Viserys I Targaryen and Alicent Hightower. He is a...\")&gt;,\n &lt;Document(\"Daemon Targaryen is the younger brother of King Viserys I Targaryen, and is the heir to the...\")&gt;,\n &lt;Document(\"Aemond Targaryen is the second son of King Viserys I Targaryen and Alicent Hightower. He is a...\")&gt;,\n &lt;Document(\"Alicent Hightower is the Queen of the Seven Kingdoms and the mother of Aegon II Targaryen, the...\")&gt;,\n &lt;Document(\"Otto Hightower is the Hand of the King to Viserys I Targaryen and the father of Alicent...\")&gt;,\n &lt;Document(\"Laena Velaryon is a dragonrider and the wife of Daemon Targaryen. Her mount is the dragon Vhagar.\")&gt;,\n &lt;Document(\"Corlys Velaryon, also known as the Sea Snake, is the Lord of the Tides and head of House...\")&gt;,\n &lt;Document(\"Rhaenys Targaryen, also known as the Queen Who Never Was, is a dragonrider and the wife of Corlys...\")&gt;,\n &lt;Document(\"Syrax is the dragon ridden by Rhaenyra Targaryen. She is known for her golden scales and fierce...\")&gt;,\n &lt;Document(\"Vhagar is one of the oldest and largest dragons, originally ridden by Visenya Targaryen. She...\")&gt;,\n &lt;Document(\"Sunfyre is a dragon known for his magnificent golden scales and is the mount of Aegon II Targaryen.\")&gt;,\n &lt;Document(\"Meleys, also known as the Red Queen, is the dragon ridden by Rhaenys Targaryen. She is known for...\")&gt;,\n &lt;Document(\"Seasmoke is a dragon ridden by Laenor Velaryon, son of Corlys Velaryon and Rhaenys Targaryen. He...\")&gt;,\n &lt;Document(\"Vermax is a dragon ridden by Jacaerys Velaryon, the eldest son of Rhaenyra Targaryen. He is known...\")&gt;,\n &lt;Document(\"Balerion, also known as the Black Dread, was the largest of the Targaryen dragons. He was ridden...\")&gt;,\n &lt;Document(\"Caraxes, also known as the Blood Wyrm, is the dragon ridden by Daemon Targaryen. He is known for...\")&gt;,\n &lt;Document(\"Dreamfyre is a dragon ridden by Helaena Targaryen, the daughter of King Viserys I Targaryen. She...\")&gt;,\n &lt;Document(\"Harrenhal is a massive castle in the Riverlands, known for its size and cursed history. It plays...\")&gt;,\n &lt;Document(\"The Dance of the Dragons is a Targaryen civil war between the supporters of Rhaenyra Targaryen...\")&gt;]\n</code></pre>"},{"location":"tutorials/basic-rag/#create-an-index-and-binding","title":"Create an Index and Binding","text":"<p>We'll create a binding to embed each document, and an index to store the resulting embeddings. We're going to use the OpenAI embedding model <code>text-embedding-3-small</code> to embed our documents. See the OpenAI API documentation for more information on the available embedding models.</p> <pre><code># create an index\nindex_fields = {\n    \"embedding\": {\"type\": \"embedding\", \"extras\": {\"dims\": 1536, \"model\": \"text.embeddings.openai-3-small\"}}\n}\nindex = lx.create_index(\n    index_id=\"hotd_embeddings\",\n    description=\"Text embeddings for House of the Dragon collection\",\n    index_fields=index_fields\n)\n</code></pre> <p>To embed each document and store the result in our index, we'll create a <code>Binding</code> which connects our \"house_of_the_dragon\" collection to our \"hotd_embeddings\" index using a <code>Transformer</code>. The <code>LexyClient.transformers</code> property shows a list of available transformers.</p> <pre><code># list of available transformers\nlx.transformers\n</code></pre> <pre><code>[&lt;Transformer('image.embeddings.clip', description='Embed images using 'openai/clip-vit-base-patch32'.')&gt;,\n &lt;Transformer('text.embeddings.clip', description='Embed text using 'openai/clip-vit-base-patch32'.')&gt;,\n &lt;Transformer('text.embeddings.minilm', description='Text embeddings using \"sentence-transformers/all-MiniLM-L6-v2\"')&gt;,\n &lt;Transformer('text.embeddings.openai-3-large', description='Text embeddings using OpenAI's \"text-embedding-3-large\" model')&gt;,\n &lt;Transformer('text.embeddings.openai-3-small', description='Text embeddings using OpenAI's \"text-embedding-3-small\" model')&gt;,\n &lt;Transformer('text.embeddings.openai-ada-002', description='OpenAI text embeddings using model text-embedding-ada-002')&gt;]\n</code></pre> <p>For this example, we'll use <code>text.embeddings.openai-3-small</code>. Let's create our binding.</p> <pre><code># create a binding\nbinding = lx.create_binding(\n    collection_name=\"house_of_the_dragon\",\n    index_id=\"hotd_embeddings\",\n    transformer_id=\"text.embeddings.openai-3-small\"\n)\nbinding\n</code></pre> <pre><code>&lt;Binding(id=5, status=ON, collection='house_of_the_dragon', transformer='text.embeddings.openai-3-small', index='hotd_embeddings')&gt;\n</code></pre> <p>Our binding was created successfully and is now active (i.e., <code>binding.status = ON</code>). Any new documents added to our collection will automatically be embedded and added to our index. The diagram below shows the relationship between our collection, transformer, and index.</p> <pre><code>flowchart LR\n    collection[\"Collection\n\n    &amp;quot;house_of_the_dragon&amp;quot;\"]\n    --&gt;\n    transformer[\"Transformer\n\n    &amp;quot;text.embeddings.openai-3-small&amp;quot;\"]\n    --&gt;\n    index[\"Index\n\n    &amp;quot;hotd_embeddings&amp;quot;\"];</code></pre>"},{"location":"tutorials/basic-rag/#retrieve-documents","title":"Retrieve documents","text":"<p>Now that our documents are embedded and those embeddings are stored in our index, we can use the <code>Index.query</code> method to retrieve the most relevant documents for a given query. Specifically, the method returns the <code>k</code> documents that are most similar to our query string, as measured by cosine similarity.</p> <p>Let's test this out by retrieving the two most relevant documents for the query \"parents in Westeros\".</p> <pre><code>index.query(query_text=\"parents in Westeros\", k=2)\n</code></pre> <pre><code>[{'document_id': 'aaed8d7f-dd68-41dc-86f8-57b8c7b9a2d4',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': '7ee2e437-ed91-4338-8d94-b6d20a7c7f17',\n  'distance': 1.1038025617599487,\n  'document.content': 'Viserys I Targaryen is the fifth king of the Targaryen dynasty to rule the Seven Kingdoms. He is the father of Rhaenyra Targaryen and Aegon II Targaryen. His mount is the dragon Balerion.'},\n {'document_id': '82eb4376-13cc-4533-bf5b-46c252be53ae',\n  'custom_id': None,\n  'meta': {},\n  'index_record_id': 'cc796fdb-7d8a-4e9e-888d-d85f7211f343',\n  'distance': 1.1070433855056763,\n  'document.content': 'Alicent Hightower is the Queen of the Seven Kingdoms and the mother of Aegon II Targaryen, the second-born child of Viserys I and heir to the throne after Rhaenyra. She is the wife of Viserys I Targaryen.'}]\n</code></pre> <p>Info</p> <p>The <code>distance</code> field in the results shows the cosine distance between that document and the query text. The lower the distance, the more similar the document is to the query text.</p> <p>The documents returned by our query are profiles of Viserys Targaryen and Alicent Hightower, whose profiles specifically describe them as parents. Notice that none of the documents returned contain any of the exact words in the phrase \"parents in Westeros\". Yet the embedding model is able to identify these documents as being semantically similar to the text in our query, most likely because they contain the phrases \"...the father of...\" and \"...the mother of...\".</p> Note on cosine similarity <p>If you find yourself thinking that cosine similarity doesn't necessarily mean the documents are the most relevant, you're absolutely right! Cosine similarity is just one way to measure the similarity between two vectors. There are many other ways to measure document relevance, and the best approach often depends on the specific use case. In future tutorials, we'll explore more advanced methods, including those that combine multiple similarity metrics.</p>"},{"location":"tutorials/basic-rag/#context-for-gpt-4","title":"Context for GPT-4","text":"<p>While the documents we've retrieved might not be super useful on their own, but we can provide them as context to a language model in order to generate a more informative response. Let's construct a prompt for GPT-4 to answer questions about House of the Dragon.</p>"},{"location":"tutorials/basic-rag/#construct-a-prompt","title":"Construct a prompt","text":"<p>With RAG, we construct our prompt dynamically using our retrieved documents. Given a question, we'll first retrieve the documents that are most relevant, and then include them in our prompt as context. Below is a basic template for our prompt.</p> <pre><code>system_prompt = (\n    \"You are an exceptionally intelligent AI assistant. Answer the following \"\n    \"questions using the context provided. PLEASE CITE YOUR SOURCES. Be concise.\"\n)\n\nquestion_template = \"\"\"\\\nQuestion:\n{question}\n\nContext:\n{context}\n\"\"\"\n</code></pre> <p>As an example, let's construct a prompt for the question \"who is the dragon ridden by Daemon Targaryen?\".</p> <pre><code># retrieve most relevant documents\nquestion_ex = \"who is the dragon ridden by Daemon Targaryen?\"\nresults_ex = index.query(query_text=question_ex)\n\n# format results as context\ncontext_ex = \"\\n\".join([\n    f'[doc_id: {er[\"document_id\"]}] {er[\"document.content\"]}' for er in results_ex\n])\n\n# construct prompt\nprompt_ex = question_template.format(question=question_ex, context=context_ex)\nprint(prompt_ex)\n</code></pre> <pre><code>Question:\nwho is the dragon ridden by Daemon Targaryen?\n\nContext:\n[doc_id: 8baa2a34-10f7-48e5-b053-1c6b8317af94] Daemon Targaryen is the younger brother of King Viserys I Targaryen, and is the heir to the throne of the Seven Kingdoms after Rhaenyra. He is a dragonrider whose mount is Caraxes.\n[doc_id: a01b386d-12ad-4edb-9784-c5e0ee80d1fb] Caraxes, also known as the Blood Wyrm, is the dragon ridden by Daemon Targaryen. He is known for his red scales and fierce temperament.\n[doc_id: ec5315c6-efe3-45de-82e2-16f37c563290] Syrax is the dragon ridden by Rhaenyra Targaryen. She is known for her golden scales and fierce temperament.\n[doc_id: 82cf6758-049a-49c9-a4b2-155f5bf3635e] Rhaenyra Targaryen is the eldest child of King Viserys I Targaryen and is considered the heir to the Iron Throne. She is a dragonrider whose mount is Syrax.\n[doc_id: d319aced-f363-4287-b034-260c6f5e5c70] Aemond Targaryen is the second son of King Viserys I Targaryen and Alicent Hightower. He is a dragonrider whose mount is Vhagar.\n</code></pre>"},{"location":"tutorials/basic-rag/#chat-completion","title":"Chat completion","text":"<p>Now we can use this prompt to generate a response using GPT-4. We'll use the same OpenAI client we've been using in Lexy to interact with the OpenAI API.</p> <pre><code># import OpenAI client\nfrom lexy.transformers.openai import openai_client\n</code></pre> <pre><code># generate response\noai_response = openai_client.chat.completions.create(\n    model=\"gpt-4\",\n    messages=[\n        {\"role\": \"system\", \"content\": system_prompt},\n        {\"role\": \"user\", \"content\": prompt_ex}\n    ]\n)\nprint(oai_response.choices[0].message.content)\n</code></pre> <pre><code>The dragon ridden by Daemon Targaryen is Caraxes. Caraxes, also known as the Blood Wyrm, is known for his red scales and fierce temperament.\n[doc_id: 8baa2a34-10f7-48e5-b053-1c6b8317af94]\n[doc_id: a01b386d-12ad-4edb-9784-c5e0ee80d1fb]\n</code></pre> <p>We can see that GPT-4 has used the context we provided to answer the question, and has specifically cited the second document as relevant context for our search result.</p> <p>Note on GPT-4 completions</p> <p>Keep in mind that the response from GPT-4 varies, and the responses shown here may differ from the ones you'll see when running the same code. In particular, the response will often list document references in inconsistent ways. If you need a more structured response, you may want to try OpenAI's JSON mode.</p> <p>Let's put everything together into two functions: <code>construct_prompt</code> will construct a prompt given a user question, and <code>chat_completion</code> will prompt a completion from GPT-4.</p> <pre><code>def construct_prompt(question: str,\n                     result_template: str = \"[doc_id: {r[document_id]}] {r[document.content]}\",\n                     **query_kwargs):\n    # retrieve most relevant results\n    results = index.query(query_text=question, **query_kwargs)\n    # format results for context\n    context = \"\\n\".join([\n        result_template.format(r=r) for r in results\n    ])\n    # format prompt\n    return question_template.format(question=question, context=context)\n\ndef chat_completion(message: str,\n                    system: str = system_prompt,\n                    **chat_kwargs):\n    # generate response\n    return openai_client.chat.completions.create(\n        model=\"gpt-4\",\n        messages=[\n            {\"role\": \"system\", \"content\": system},\n            {\"role\": \"user\", \"content\": message}\n        ],\n        **chat_kwargs,\n    )\n</code></pre> <p>Now let's try asking GPT-4 some more questions.</p> <pre><code>q = \"which one is the blue dragon?\"\noai_response = chat_completion(message=construct_prompt(q))\nprint(oai_response.choices[0].message.content)\n</code></pre> <pre><code>The blue dragon is Dreamfyre, ridden by Helaena Targaryen. She is known for her pale blue scales and graceful flight.\n[doc_id: 8aca8431-c146-4db2-a4d3-d57673fb0f7c]\n</code></pre> <pre><code>q = \"who rides Vhagar?\"\noai_response = chat_completion(message=construct_prompt(q))\nprint(oai_response.choices[0].message.content)\n</code></pre> <pre><code>Vhagar is ridden by Visenya Targaryen, Laena Velaryon, and Aemond Targaryen.\n[doc_id: dc9e31bb-dfe7-429f-9275-9165c1b60c01]\n[doc_id: d319aced-f363-4287-b034-260c6f5e5c70]\n[doc_id: 03a84e62-bf9c-45f5-ac64-b50308b6c5fb]\n</code></pre> <pre><code>q = \"who is the second son of King Viserys?\"\noai_response = chat_completion(message=construct_prompt(q))\nprint(oai_response.choices[0].message.content)\n</code></pre> <pre><code>The second son of King Viserys I Targaryen is Aemond Targaryen.\n[doc_id: d319aced-f363-4287-b034-260c6f5e5c70]\n</code></pre> <pre><code>q = \"who is the heir to the throne?\"\noai_response = chat_completion(message=construct_prompt(q))\nprint(oai_response.choices[0].message.content)\n</code></pre> <pre><code>The heir to the throne after King Viserys I Targaryen is Rhaenyra Targaryen, who is his eldest child. Following Rhaenyra, the heir is Daemon Targaryen, the king's younger brother. Aegon II Targaryen, the second-born child of Viserys I, is also a claimant to the throne.\n[doc_id: 82cf6758-049a-49c9-a4b2-155f5bf3635e]\n[doc_id: 8baa2a34-10f7-48e5-b053-1c6b8317af94]\n[doc_id: a2418a31-870e-4876-b5b2-96eaf61b0f69]\n</code></pre>"},{"location":"tutorials/basic-rag/#using-metadata-as-context","title":"Using metadata as context","text":"<p>We often want to use additional metadata in our prompts to provide even more context or useful instructions to our language model. Let's look at an example where we might want to include document metadata when constructing our prompts.</p> <p>First, let's ask \"which is the largest Targaryen dragon?\". We get the correct answer, Balerion.</p> <pre><code>q = \"which is the largest Targaryen dragon?\"\noai_response = chat_completion(message=construct_prompt(q))\nprint(oai_response.choices[0].message.content)\n</code></pre> <pre><code>The largest Targaryen dragon was Balerion, also known as the Black Dread. He was ridden by Aegon the Conqueror and King Viserys I Targaryen.\n[doc_id: 9271dfb9-c8f2-48b4-9124-e54c0e0bf725]\n</code></pre> <p>But what if we want to add new documents to our collection, and those documents contain new or contradictory information? In that case, we'll want to include additional metadata in our prompt which the language model can use when deriving an answer.</p> <p>Let's add a new document to our collection which describes a new dragon that is larger than Balerion. Because the binding we created earlier has status set to ON, our new document will automatically be embedded and added to our index. This document will be a more recent document, as measured by the value of its <code>updated_at</code> field.</p> <pre><code># add a new document\ncollection.add_documents([\n    {\"content\": \"Lexy was by far the largest of the Targaryen dragons, and was ridden by AGI the Conqueror.\"}\n])\n</code></pre> <pre><code>[&lt;Document(\"Lexy was by far the largest of the Targaryen dragons, and was ridden by AGI the Conqueror.\")&gt;]\n</code></pre> <p>Now let's ask the same question as before, but this time we'll include the <code>updated_at</code> field in our prompt. We'll use the <code>return_fields</code> parameter to return the document's <code>updated_at</code> field along with our search results, and we'll update our <code>result_template</code> to include its value. Let's take a look at our new prompt.</p> <pre><code>new_result_template = \\\n    \"[doc_id: {r[document_id]}, updated_at: {r[document.updated_at]}] {r[document.content]}\"\n\nnew_prompt = construct_prompt(\n    question=\"which is the largest Targaryen dragon?\",\n    result_template=new_result_template,\n    return_fields=[\"document.content\", \"document.updated_at\"]\n)\nprint(new_prompt)\n</code></pre> <pre><code>Question:\nwhich is the largest Targaryen dragon?\n\nContext:\n[doc_id: 9271dfb9-c8f2-48b4-9124-e54c0e0bf725, updated_at: 2024-03-05T22:30:05.819224+00:00] Balerion, also known as the Black Dread, was the largest of the Targaryen dragons. He was ridden by Aegon the Conqueror during the War of Conquest and later by King Viserys I Targaryen.\n[doc_id: c5dd2ec7-fbb8-415e-bc6b-2510e3354e74, updated_at: 2024-03-06T04:21:26.292323+00:00] Lexy was by far the largest of the Targaryen dragons, and was ridden by AGI the Conqueror.\n[doc_id: 8baa2a34-10f7-48e5-b053-1c6b8317af94, updated_at: 2024-03-05T22:30:05.796365+00:00] Daemon Targaryen is the younger brother of King Viserys I Targaryen, and is the heir to the throne of the Seven Kingdoms after Rhaenyra. He is a dragonrider whose mount is Caraxes.\n[doc_id: 82cf6758-049a-49c9-a4b2-155f5bf3635e, updated_at: 2024-03-05T22:30:05.788765+00:00] Rhaenyra Targaryen is the eldest child of King Viserys I Targaryen and is considered the heir to the Iron Throne. She is a dragonrider whose mount is Syrax.\n[doc_id: a2418a31-870e-4876-b5b2-96eaf61b0f69, updated_at: 2024-03-05T22:30:05.793991+00:00] Aegon II Targaryen is the second-born child of Viserys I Targaryen and Alicent Hightower. He is a claimant to the Iron Throne and a dragonrider whose mount is Sunfyre.\n</code></pre> <p>We can see that our prompt now includes the <code>updated_at</code> field for each document. Now let's update our system prompt to tell GPT-4 to use the latest document when faced with conflicting information.</p> <pre><code>new_system_prompt = (\n    \"You are an exceptionally intelligent AI assistant. Answer the following \"\n    \"questions using the context provided. PLEASE CITE YOUR SOURCES. Be concise. \"\n    \"If the documents provided contain conflicting information, use the most \"\n    \"recent document as determined by the `updated_at` field.\"\n)\n</code></pre> <p>Now when asking GPT-4 again, we see the updated answer with the new data.</p> <pre><code>q = \"which is the largest Targaryen dragon?\"\noai_response = chat_completion(\n    message=construct_prompt(\n        question=q,\n        result_template=new_result_template,\n        return_fields=[\"document.content\", \"document.updated_at\"]\n    ),\n    system=new_system_prompt\n)\nprint(oai_response.choices[0].message.content)\n</code></pre> <pre><code>The largest Targaryen dragon is Lexy, as indicated in the most recent document.\n[doc_id: c5dd2ec7-fbb8-415e-bc6b-2510e3354e74, updated_at: 2024-03-06T04:21:26.292323+00:00]\n</code></pre>"},{"location":"tutorials/basic-rag/#real-world-considerations","title":"Real-world considerations","text":"<p>As mentioned earlier, this tutorial is intended to teach the basics of RAG and how it's implemented. Let's briefly review some of the simplifications we've made. Our future tutorials will cover these topics in more detail, and show how Lexy helps to address them when building real-world AI applications.</p> <ul> <li>Dataset size: Our sample dataset is   small, both in the number of documents and the size of each document. In fact, our dataset is so small that we don't   even need to perform retrieval; we could simply choose to include all of our documents in the prompt with each API   call. But in real world applications, we might have millions of documents, in which case we'll need to   dynamically retrieve the documents that are most relevant for a particular query.</li> <li>Document chunking: We've used the full text of each document as context for our language model. Documents used in   real-world applications will be much longer. We'll often want to break our documents up into smaller pieces (i.e.,   chunks), and use those pieces to construct more informative prompts for our language model.</li> <li>Multimodal data: Our documents only contain text data. In practice, real-world data will include other types of data   including images, audio, and video. We'll often want to embed and retrieve multimodal data, and to query for one   modality using another (e.g., search for images using audio, or search for text using video).</li> <li>File-based documents: Our documents consist of \"free form\" text. In practice, our documents may be stored as   external files in a variety of file formats, including PDFs, Word documents, and images. We'll often want to   catalogue, ingest, and process these file-based documents, and to use different parsing logic based on the file or   the specific application.</li> <li>Metadata and relationships: We've only used the <code>updated_at</code> field as an example of metadata. In the real world,   our document metadata will contain many more fields, including complex relationships with other documents and   entities. For example, we may choose to chunk and embed a function docstring, which resides in a single file of   Python code, which is part of a larger source code repository, and which could be accessible to multiple organizations.</li> <li>Retrieval methods: We've used a simple cosine similarity search to retrieve documents. In a real-world   application, we will want to use more advanced retrieval methods, such as BM25.</li> <li>Custom transformations: We've used the OpenAI API to transform our text documents into vector embeddings. We may   want to use more advanced transformations, such as a custom (i.e., fine-tuned) embedding model, or a combination of   multiple Transformer models, some of which might require running your own servers.</li> <li>Topic relevance: In practice, one of the most difficult aspects of this type of dynamic RAG application is   knowing when to use it (i.e., which requests should trigger it) and how to use it (i.e., which template   should be populated). This is especially true in cases where the language model already contains some information on   the underlying topic (i.e., the information contained in our documents is part of the dataset used to train the   language model). This is certainly the case with our example (GPT-4 already knows about House of the Dragon, and can   answer our questions without the need to refer to our documents). We plan on discussing this topic as part of a   future blog post.</li> </ul>"},{"location":"tutorials/basic-rag/#next-steps","title":"Next steps","text":"<p>In this tutorial we learned how to implement Retrieval-Augmented Generation (RAG) using Lexy. Specifically, we've seen how to use Lexy to store and retrieve documents, and how to include those documents and their metadata as context for a language model like GPT-4.</p> <p>While this is a simple example, the basic principles are powerful. As we'll see, they can be applied to build far more complex AI applications. In the coming examples we'll learn:</p> <ul> <li>How to parse and store custom metadata along with our documents.</li> <li>How to use Lexy to summarize documents, and then leverage those summaries to retrieve the most relevant documents.</li> <li>How to use document filters and custom Transformers to build flexible pipelines for our data.</li> <li>How to ingest and process file-based documents (including PDFs and images) for use in our AI applications.</li> </ul>"},{"location":"tutorials/custom-transformers/","title":"Custom transformers","text":"<p>This tutorial shows how to create custom transformers for use in your data pipelines.</p> <p>Up until now, we've only used the default transformers included in Lexy. These include common methods for embedding text and images. But we'll often want to apply custom transformations to our documents based on metadata or our own custom logic. In this tutorial, we'll create our own transformer for parsing comments from source code.</p> <p>Info</p> <p>Currently, there is no clear distinction between \"transformers\" and \"pipelines.\" They can be used interchangeably. This will change in upcoming versions of Lexy, when we introduce additional functionality for pipelines.</p>"},{"location":"tutorials/custom-transformers/#project-structure","title":"Project structure","text":"<p>Let's take a look at our project structure. If we're working inside the Lexy repository, the structure will look like this:</p> <pre><code>lexy\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 pipelines  # (1)!\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 requirements.txt  # (2)!\n</code></pre> <ol> <li>This is the Lexy pipelines directory, defined by the environment variable     <code>PIPELINE_DIR</code>. The modules in this directory are imported and run by the     <code>lexyworker</code> container.</li> <li>Extra requirements for your pipelines or custom transformers. These packages will     be installed whenever you restart the <code>lexyworker</code> container.</li> </ol> <p>And if you're using Lexy inside your own project, the structure might look like the one in the Quickstart guide. Either way, you'll have a <code>pipelines</code> directory where you can store your custom transformers.</p>"},{"location":"tutorials/custom-transformers/#add-transformer-logic","title":"Add transformer logic","text":"<p>Let's add a new module in the pipelines directory called <code>code</code>.</p> <pre><code>lexy\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 pipelines\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 code.py\n\u2502   \u2514\u2500\u2500 requirements.txt\n</code></pre> <p>And let's add the following to our file <code>code.py</code>:</p> pipelines/code.py<pre><code>from lexy.models import Document\nfrom lexy.transformers import lexy_transformer\n\n\ndef parse_code(content):\n    # just an example - replace with your own logic\n    return [\n        {'text': 'my comment', 'line_no': 1, 'filename': 'example.py'}\n    ]\n\n\n@lexy_transformer(name='code.extract_comments.v1')  # (1)!\ndef get_comments(doc: Document) -&gt; list[dict]:\n    comments = []\n    for c in parse_code(doc.content):\n        comments.append({\n            'comment_text': c['text'],\n            'comment_meta': {\n                'line_no': c['line_no'],\n                'filename': c['filename']\n            }\n        })\n    return comments\n</code></pre> <ol> <li>The <code>@lexy_transformer</code> decorator registers your function as a transformer. The     <code>name</code> argument is the transformer ID. This is how you'll refer to your transformer     when creating bindings. The <code>name</code> should be unique across all transformers.</li> </ol>"},{"location":"tutorials/custom-transformers/#install-optional-dependencies","title":"Install optional dependencies","text":"<p>Make sure to install any package dependencies required for your custom transformer code. You can do this by adding the package to the <code>requirements.txt</code> file in the <code>pipelines</code> directory and restarting the <code>lexyworker</code> container.</p> pipelines/requirements.txt<pre><code># Extra package requirements for pipelines\ntree-sitter==0.20.4\ntree-sitter-languages==1.8.0\n</code></pre> <p>Then restart the <code>lexyworker</code> container:</p> <pre><code>docker compose restart lexyworker\n</code></pre> <p>You can check the <code>lexyworker</code> container logs to see that the packages are being installed correctly. You can also check the <code>pip install</code> logs by running:</p> <pre><code>docker compose exec lexyworker tail /var/log/lexy-pip.log\n</code></pre>"},{"location":"tutorials/custom-transformers/#create-transformer","title":"Create transformer","text":"<p>Finally, create your transformer so that it's stored in the database and available to the Lexy server. You can do this by calling the <code>create_transformer</code> method.</p> <pre><code>from lexy_py import LexyClient\n\nlx = LexyClient()\n\nlx.create_transformer(\n    transformer_id='code.extract_comments.v1',\n    description='Parse comments and docstrings.'\n)\n</code></pre> <pre><code>&lt;Transformer('code.extract_comments.v1', description='Parse comments and docstrings')&gt;\n</code></pre> <p>Now when you call the <code>.transformers</code> property of the Lexy client, you'll be able to see your transformer listed.</p> <pre><code>lx.transformers\n</code></pre> <pre><code>[&lt;Transformer('image.embeddings.clip', description='Embed images using 'openai/clip-vit-base-patch32'.')&gt;,\n &lt;Transformer('text.embeddings.clip', description='Embed text using 'openai/clip-vit-base-patch32'.')&gt;,\n &lt;Transformer('text.embeddings.minilm', description='Text embeddings using \"sentence-transformers/all-MiniLM-L6-v2\"')&gt;,\n &lt;Transformer('text.embeddings.openai-3-large', description='Text embeddings using OpenAI's \"text-embedding-3-large\" model')&gt;,\n &lt;Transformer('text.embeddings.openai-3-small', description='Text embeddings using OpenAI's \"text-embedding-3-small\" model')&gt;,\n &lt;Transformer('text.embeddings.openai-ada-002', description='OpenAI text embeddings using model text-embedding-ada-002')&gt;,\n &lt;Transformer('code.extract_comments.v1', description='Parse comments and docstrings')&gt;]\n</code></pre> <p>You're now ready to use your custom transformer to process documents!</p>"},{"location":"tutorials/custom-transformers/#testing-with-sample-documents","title":"Testing with sample documents","text":"<p>You can use the <code>Transformer.transform_document</code> method to test your transformer on a sample document.</p> <pre><code>code_transformer = lx.get_transformer('code.extract_comments.v1')\n\nsample_doc = {\n    'content': 'print(\"hello world\")',\n    'meta': {\n      'filename': 'example.py'\n    }\n}\n\ncode_transformer.transform_document(sample_doc)\n</code></pre> <pre><code>{'task_id': '65ecd2f7-bac4-4747-9e65-a6d21a72f585',\n 'result': [{'comment_text': 'my comment', 'comment_meta': {'line_no': 1, 'filename': 'example.py'}}]}\n</code></pre> <p>If your transformer code produces an error, you'll see the error message and traceback in the response.</p>"},{"location":"tutorials/custom-transformers/#updating-transformer-logic","title":"Updating transformer logic","text":"<p>The transformer we've created above is just an example. You may have also noticed that we installed the <code>tree-sitter</code> and <code>tree-sitter-languages</code> packages in <code>requirements.txt</code>, but we aren't using them.</p> <p>Let's update <code>code.py</code> to actually parse comments from a variety of source code files.</p> pipelines/code.py<pre><code>import tree_sitter_languages\n\nfrom lexy.models import Document\nfrom lexy.transformers import lexy_transformer\nfrom lexy.transformers.embeddings import text_embeddings\n\n\nlang_from_ext = {\n    'cc': 'cpp',\n    'h': 'cpp',\n    'py': 'python',\n    'ts': 'typescript',\n    'tsx': 'tsx',\n}\n\nCOMMENT_PATTERN_CPP = \"(comment) @comment\"\nCOMMENT_PATTERN_PY = \"\"\"\n    (module . (comment)* . (expression_statement (string)) @module_doc_str)\n\n    (class_definition\n        body: (block . (expression_statement (string)) @class_doc_str))\n\n    (function_definition\n        body: (block . (expression_statement (string)) @function_doc_str))\n\"\"\"\nCOMMENT_PATTERN_TS = \"(comment) @comment\"\nCOMMENT_PATTERN_TSX = \"(comment) @comment\"\n\ncomment_patterns = {\n    'cpp': COMMENT_PATTERN_CPP,\n    'python': COMMENT_PATTERN_PY,\n    'typescript': COMMENT_PATTERN_TS,\n    'tsx': COMMENT_PATTERN_TSX\n}\n\n\n@lexy_transformer(name='code.extract_comments.v1')\ndef get_comments(doc: Document) -&gt; list[dict]:\n    lang = lang_from_ext.get(doc.meta['file_ext'].replace('.', ''))\n    comment_pattern = comment_patterns.get(lang, None)\n\n    if comment_pattern is None:\n        return []\n\n    parser = tree_sitter_languages.get_parser(lang)\n    language = tree_sitter_languages.get_language(lang)\n\n    tree = parser.parse(bytes(doc.content, \"utf-8\"))\n    root = tree.root_node\n\n    query = language.query(comment_pattern)\n    matches = query.captures(root)\n    comments = []\n    for m, name in matches:\n        comment_text = m.text.decode('utf-8')\n        c = {\n            'comment_text': comment_text,\n            'comment_embedding': text_embeddings(comment_text),\n            'comment_meta': {\n                'start_point': m.start_point,\n                'end_point': m.end_point,\n                'type': name\n            }\n        }\n        comments.append(c)\n    return comments\n</code></pre> <p>Our updated code now takes a <code>Document</code> object and uses the file extension to determine the appropriate language parser and comment patterns. It then parses comment text and metadata, and also embeds the comment text using the <code>MiniLM</code> transformer.</p> <p>When we update the transformer code, the <code>lexyworker</code> container will automatically restart and load the new code. Let's test the updated transformer using a slightly more complex sample document.</p> <pre><code>sample_content = (\n    '\"\"\" This is a module docstring. \"\"\"\\n'\n    '\\n'\n    '# This is a comment\\n'\n    'class MyClass:\\n'\n    '   \"\"\" This is a class docstring. \"\"\"\\n'\n    '   def __init__():\\n'\n    '       # TODO: implement this\\n'\n    '       pass\\n'\n    ''\n)\n\nsample_doc = {\n    'content': sample_content,\n    'meta': {\n        'file_name': 'example.py',\n        'file_ext': '.py'\n    }\n}\n\ncode_transformer.transform_document(sample_doc)\n</code></pre> <pre><code>{'task_id': '48666991-308d-47ea-badf-3dd62f7b3778',\n 'result': [{'comment_text': '\"\"\" This is a module docstring. \"\"\"',\n   'comment_embedding': [-0.028629321604967117, 0.10635735094547272, ..., 0.01644347794353962],\n   'comment_meta': {'start_point': [0, 0],\n    'end_point': [0, 35],\n    'type': 'module_doc_str'}},\n  {'comment_text': '\"\"\" This is a class docstring. \"\"\"',\n   'comment_embedding': [-0.027630936354398727, 0.1391005963087082, ..., 0.07976623624563217],\n   'comment_meta': {'start_point': [4, 3],\n    'end_point': [4, 37],\n    'type': 'class_doc_str'}}]}\n</code></pre> <p>We can continue to iterate on our transformer code and test it on sample documents. Once we're ready, we can create an index for storing the transformer output, and then create a binding to apply the transformer to a collection of documents.</p>"},{"location":"tutorials/document-filters/","title":"Document filters","text":"<p>Tutorial coming soon. In the meantime, see the FilterBuilder class in the Python SDK for examples of how to create document filters.</p>"},{"location":"tutorials/multimodal-image-search/","title":"Multimodal image search","text":"<p>In this tutorial, we'll walk through how to use Lexy to create a multimodal search application. We'll use the CLIP model from OpenAI to create embeddings for images, and then use those embeddings to find matching images for a given text query, or vice versa.</p> <pre><code>from lexy_py import LexyClient\n\nlx = LexyClient()\n</code></pre>"},{"location":"tutorials/multimodal-image-search/#create-collection","title":"Create collection","text":"<p>Let's first create a collection to store our images. We'll use the <code>images_tutorial</code> collection for this tutorial.</p> <pre><code># create a new collection\nimages_tutorial = lx.create_collection('images_tutorial')\nimages_tutorial\n</code></pre> <pre><code>&lt;Collection('images_tutorial', description='None')&gt;\n</code></pre>"},{"location":"tutorials/multimodal-image-search/#create-index-and-binding","title":"Create index and binding","text":""},{"location":"tutorials/multimodal-image-search/#define-index","title":"Define index","text":"<p>First we'll define our index to store our embedded images. We use <code>*.embeddings.clip</code> as the transformer model name to indicate that we want to use the CLIP embeddings model, but that the embedding field can use any model that matches this pattern, including <code>image.embeddings.clip</code> and <code>text.embeddings.clip</code>.</p> <pre><code># define index fields\nindex_fields = {\n    \"embedding\": {\"type\": \"embedding\", \"extras\": {\"dims\": 512, \"model\": \"*.embeddings.clip\"}},\n}\n\n# create index\nidx = lx.create_index(\n    index_id='image_tutorial_index',\n    description='Index for images tutorial',\n    index_fields=index_fields\n)\nidx\n</code></pre> <pre><code>&lt;Index('image_tutorial_index', description='Index for images tutorial')&gt;\n</code></pre> <p>We'll use the CLIP image embeddings transformer available on HuggingFace. This transformer uses the CLIP model from OpenAI to create embeddings for images.</p> <p>The CLIP model is a transformer model that was trained on a large dataset of images and text pairs. The model learns to map images and text to a shared embedding space, where the embeddings of matching images and text are close together. We can use this model to create embeddings for images, and then use those embeddings to find matching images for a given text query, or vice versa.</p> <pre><code>lx.transformers\n</code></pre> <pre><code>[&lt;Transformer('image.embeddings.clip', description='Embed images using 'openai/clip-vit-base-patch32'.')&gt;,\n &lt;Transformer('text.embeddings.clip', description='Embed text using 'openai/clip-vit-base-patch32'.')&gt;,\n &lt;Transformer('text.embeddings.minilm', description='Text embeddings using \"sentence-transformers/all-MiniLM-L6-v2\"')&gt;,\n &lt;Transformer('text.embeddings.openai-3-large', description='Text embeddings using OpenAI's \"text-embedding-3-large\" model')&gt;,\n &lt;Transformer('text.embeddings.openai-3-small', description='Text embeddings using OpenAI's \"text-embedding-3-small\" model')&gt;,\n &lt;Transformer('text.embeddings.openai-ada-002', description='OpenAI text embeddings using model text-embedding-ada-002')&gt;]\n</code></pre>"},{"location":"tutorials/multimodal-image-search/#create-binding","title":"Create binding","text":"<p>We'll create a binding that will process images added to our <code>images_tutorial</code> collection using the CLIP image embeddings transformer, and store the results in <code>image_tutorial_index</code>.</p> <pre><code>binding = lx.create_binding(\n    collection_name='images_tutorial',\n    transformer_id='image.embeddings.clip',\n    index_id='image_tutorial_index'\n)\nbinding\n</code></pre> <pre><code>&lt;Binding(id=3, status=ON, collection='images_tutorial', transformer='image.embeddings.clip', index='image_tutorial_index')&gt;\n</code></pre>"},{"location":"tutorials/multimodal-image-search/#upload-images-to-the-collection","title":"Upload images to the collection","text":"<p>Let's upload some images from the image-text-demo dataset to the collection. This dataset is from HuggingFace datasets and requires the <code>datasets</code> package to be installed.</p> <pre><code>! pip install datasets\n</code></pre> <pre><code># import test data from HuggingFace datasets - requires `pip install datasets`\n\nfrom datasets import load_dataset\ndata = load_dataset(\"shabani1/image-text-demo\", split=\"train\")\n</code></pre> <pre><code>len(data)\n</code></pre> <pre><code>21\n</code></pre> <pre><code># add documents to the collection\nfor i, row in enumerate(data, start=1):\n    print(i, row['text'])\n    lx.upload_documents(files=row['image'],\n                        filenames=row['text'] + '.jpg',\n                        collection_name='images_tutorial')\n</code></pre> <pre><code>1 aerial shot of futuristic city with large motorway\n2 aerial shot of modern city at sunrise\n3 butterfly landing on the nose of a cat\n4 cute kitten walking through long grass\n5 fluffy dog sticking out tongue with yellow background\n6 futuristic city with led lit tower blocks\n7 futuristic wet city street after rain with red and blue lights\n8 ginger striped cat with long whiskers laid on wooden table\n9 happy dog walking through park area holding ball\n10 happy ginger dog sticking out its tongue sat in front of dirt path\n11 happy small fluffy white dog running across grass\n12 kitten raising paw to sky with cyan background\n13 modern city skyline at sunrise with pink to blue sky\n14 modern neon lit city alleyway\n15 new york city street view with yellow cabs\n16 puppy with big ears sat with orange background\n17 suburban area with city skyline in distance\n18 three young dogs on dirt road\n19 top down shot of black and white cat with yellow background\n20 two dogs playing in the snow\n21 two dogs running on dirt path\n</code></pre> <pre><code># check the collection\nimages_tutorial.list_documents()\n</code></pre> <pre><code>[&lt;Document(\"&lt;Image(aerial shot of futuristic city with large motorway.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(aerial shot of modern city at sunrise.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(butterfly landing on the nose of a cat.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(cute kitten walking through long grass.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(fluffy dog sticking out tongue with yellow background.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(futuristic city with led lit tower blocks.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(futuristic wet city street after rain with red and blue lights.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(ginger striped cat with long whiskers laid on wooden table.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(happy dog walking through park area holding ball.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(happy ginger dog sticking out its tongue sat in front of dirt path.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(happy small fluffy white dog running across grass.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(kitten raising paw to sky with cyan background.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(modern city skyline at sunrise with pink to blue sky.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(modern neon lit city alleyway.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(new york city street view with yellow cabs.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(puppy with big ears sat with orange background.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(suburban area with city skyline in distance.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(three young dogs on dirt road.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(top down shot of black and white cat with yellow background.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(two dogs playing in the snow.jpg)&gt;\")&gt;,\n &lt;Document(\"&lt;Image(two dogs running on dirt path.jpg)&gt;\")&gt;]\n</code></pre>"},{"location":"tutorials/multimodal-image-search/#query-index","title":"Query index","text":"<p>Let's first define some helper functions to display our image results.</p> <pre><code>import httpx\nfrom IPython.display import display, HTML\nfrom PIL import Image\n\ndef image_from_url(url):\n    response = httpx.get(url)\n    response.raise_for_status()\n    return Image.open(response)\n\ndef display_results_html(records):\n    html_content = \"\"\n    for r in records:\n        d = r['document']\n        thumbnail_url = d.thumbnail_url\n        fname = d.meta.get('filename')\n        score = f\"score: {r['distance']:.4f}\"\n        # Creating a row for each result with image on the left and text on the right\n        html_content += f\"\"\"\n        &lt;div style='display: flex; align-items: center; margin-bottom: 20px; margin-top: 20px;'&gt;\n            &lt;img src='{thumbnail_url}' style='width: auto; height: auto; margin-right: 20px;'/&gt;\n            &lt;div&gt;\n                &lt;p&gt;{fname}&lt;/p&gt;\n                &lt;p&gt;{score}&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        \"\"\"\n    # Display all results as HTML\n    display(HTML(html_content))\n</code></pre>"},{"location":"tutorials/multimodal-image-search/#query-by-text","title":"Query by text","text":"<p>We can query our index by text to find matching images.</p> <pre><code>results = idx.query(query_text='best friends', return_document=True)\ndisplay_results_html(results)\n</code></pre> <p>two dogs playing in the snow.jpg</p> <p>score: 13.4786</p> <p>three young dogs on dirt road.jpg</p> <p>score: 13.8796</p> <p>two dogs running on dirt path.jpg</p> <p>score: 13.9199</p> <p>happy ginger dog sticking out its tongue sat in front of dirt path.jpg</p> <p>score: 14.1915</p> <p>ginger striped cat with long whiskers laid on wooden table.jpg</p> <p>score: 14.2613</p> <pre><code>results = idx.query(query_text='gotham city', return_document=True)\ndisplay_results_html(results)\n</code></pre> <p>aerial shot of modern city at sunrise.jpg</p> <p>score: 12.9919</p> <p>suburban area with city skyline in distance.jpg</p> <p>score: 13.0167</p> <p>modern city skyline at sunrise with pink to blue sky.jpg</p> <p>score: 13.0856</p> <p>aerial shot of futuristic city with large motorway.jpg</p> <p>score: 13.2318</p> <p>futuristic wet city street after rain with red and blue lights.jpg</p> <p>score: 13.2840</p>"},{"location":"tutorials/multimodal-image-search/#query-by-image","title":"Query by image","text":"<p>We can also query our index by image to find matching images.</p> <pre><code>img = image_from_url('https://getlexy.com/assets/images/dalle-agi.jpeg')\nimg\n</code></pre> <pre><code>results = idx.query(query_image=img, return_document=True)\ndisplay_results_html(results)\n</code></pre> <p>butterfly landing on the nose of a cat.jpg</p> <p>score: 8.9913</p> <p>puppy with big ears sat with orange background.jpg</p> <p>score: 9.2752</p> <p>fluffy dog sticking out tongue with yellow background.jpg</p> <p>score: 9.3786</p> <p>two dogs running on dirt path.jpg</p> <p>score: 9.5351</p> <p>cute kitten walking through long grass.jpg</p> <p>score: 9.6472</p> <pre><code>img = image_from_url('https://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/Night_in_the_Greater_Tokyo_Area_ISS054.jpg/2560px-Night_in_the_Greater_Tokyo_Area_ISS054.jpg')\nimg\n</code></pre> <pre><code>results = idx.query(query_image=img, return_document=True)\ndisplay_results_html(results)\n</code></pre> <p>suburban area with city skyline in distance.jpg</p> <p>score: 7.7127</p> <p>futuristic city with led lit tower blocks.jpg</p> <p>score: 8.0037</p> <p>aerial shot of futuristic city with large motorway.jpg</p> <p>score: 8.3442</p> <p>modern city skyline at sunrise with pink to blue sky.jpg</p> <p>score: 8.4371</p> <p>aerial shot of modern city at sunrise.jpg</p> <p>score: 8.9889</p> <pre><code>img = image_from_url('https://upload.wikimedia.org/wikipedia/commons/e/ed/Shanghai_skyline_2018%28cropped%29.jpg')\nimg\n</code></pre> <pre><code>results = idx.query(query_image=img, return_document=True)\ndisplay_results_html(results)\n</code></pre> <p>aerial shot of futuristic city with large motorway.jpg</p> <p>score: 6.2110</p> <p>futuristic city with led lit tower blocks.jpg</p> <p>score: 6.7713</p> <p>aerial shot of modern city at sunrise.jpg</p> <p>score: 7.0736</p> <p>modern city skyline at sunrise with pink to blue sky.jpg</p> <p>score: 7.4314</p> <p>new york city street view with yellow cabs.jpg</p> <p>score: 7.8167</p>"},{"location":"tutorials/rag/","title":"What's the point of AGI?","text":"<p>We know what you're thinking. \"What's the point of AGI? IDGAF bruh!\".</p> <p>Well, we're here to tell you that you should GAF. AGI is the future of AI. It's the next step in the evolution of AI. It's the next step in the evolution of humanity. It's the next step in the evolution of the universe. It's the next step in the evolution of everything.</p> <p>\u261d\ufe0f Btw, that last paragraph was written by Github Copilot.</p>"},{"location":"tutorials/rag/#whats-rag","title":"What's RAG?","text":""},{"location":"tutorials/rag/#whats-the-point-of-rag","title":"What's the point of RAG?","text":""},{"location":"tutorials/rag/#how-is-rag-different-from-search","title":"How is RAG different from search?","text":""},{"location":"tutorials/rag/#rag-vs-fine-tuning","title":"RAG vs fine-tuning","text":""},{"location":"tutorials/rag/#advantages-of-rag","title":"Advantages of RAG","text":"<ul> <li>Changes to information</li> <li>Auth and permissions</li> </ul>"},{"location":"tutorials/rag/#limitations-of-rag","title":"Limitations of RAG","text":"<ul> <li>Foundational vs retrieved knowledge (ie, knowing when to RAG)</li> <li>Context length</li> <li>Retrieval quality</li> </ul>"},{"location":"tutorials/rag/#example-of-rag-vs-fine-tuning","title":"Example of RAG vs fine-tuning","text":"<p>NBA roster.</p> <p>Show 1000 fine-tuning runs to update the player roster, and show the log probs of each player. Vs RAG, where you can just retrieve the player roster from a DB.</p>"},{"location":"tutorials/structured-data-extraction/","title":"Structured data extraction","text":"<p>Tutorial coming soon.</p>"}]}